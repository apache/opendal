/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

// DO NOT EDIT IT MANUALLY. This file is generated by opendal/dev/generate/java.rs.

package org.apache.opendal;

import java.time.Duration;
import java.util.HashMap;
import java.util.Map;
import lombok.AccessLevel;
import lombok.Builder;
import lombok.Data;
import lombok.NonNull;
import lombok.RequiredArgsConstructor;

/**
 * Service configurations that are mapped from
 * <a href="https://docs.rs/opendal/latest/opendal/services/index.html">OpenDAL's services</a>.
 */
@SuppressWarnings("unused") // intended to be used by users
public interface ServiceConfig {
    /**
     * The scheme of the service.
     *
     * @return the scheme
     */
    String scheme();

    /**
     * Convert the structured config to a type erased config map.
     *
     * @return the config map
     */
    Map<String, String> configMap();

    /**
     * Configuration for service aliyun_drive.
     */
    @Builder
    @Data
    @RequiredArgsConstructor(access = AccessLevel.PRIVATE)
    class AliyunDrive implements ServiceConfig {
        /**
         * <p>The drive_type of this backend.</p>
         * <p>All operations will happen under this type of drive.</p>
         * <p>Available values are <code>default</code>, <code>backup</code> and <code>resource</code>.</p>
         * <p>Fallback to default if not set or no other drives can be found.</p>
         */
        private final @NonNull String driveType;
        /**
         * <p>The Root of this backend.</p>
         * <p>All operations will happen under this root.</p>
         * <p>Default to <code>/</code> if not set.</p>
         */
        private final String root;
        /**
         * <p>The access_token of this backend.</p>
         * <p>Solution for client-only purpose. #4733</p>
         * <p>Required if no client_id, client_secret and refresh_token are provided.</p>
         */
        private final String accessToken;
        /**
         * <p>The client_id of this backend.</p>
         * <p>Required if no access_token is provided.</p>
         */
        private final String clientId;
        /**
         * <p>The client_secret of this backend.</p>
         * <p>Required if no access_token is provided.</p>
         */
        private final String clientSecret;
        /**
         * <p>The refresh_token of this backend.</p>
         * <p>Required if no access_token is provided.</p>
         */
        private final String refreshToken;

        @Override
        public String scheme() {
            return "aliyun_drive";
        }

        @Override
        public Map<String, String> configMap() {
            final HashMap<String, String> map = new HashMap<>();
            map.put("drive_type", driveType);
            if (root != null) {
                map.put("root", root);
            }
            if (accessToken != null) {
                map.put("access_token", accessToken);
            }
            if (clientId != null) {
                map.put("client_id", clientId);
            }
            if (clientSecret != null) {
                map.put("client_secret", clientSecret);
            }
            if (refreshToken != null) {
                map.put("refresh_token", refreshToken);
            }
            return map;
        }
    }

    /**
     * Configuration for service alluxio.
     */
    @Builder
    @Data
    @RequiredArgsConstructor(access = AccessLevel.PRIVATE)
    class Alluxio implements ServiceConfig {
        /**
         * <p>root of this backend.</p>
         * <p>All operations will happen under this root.</p>
         * <p>default to <code>/</code> if not set.</p>
         */
        private final String root;
        /**
         * <p>endpoint of this backend.</p>
         * <p>Endpoint must be full uri, mostly like <code>http://127.0.0.1:39999</code>.</p>
         */
        private final String endpoint;

        @Override
        public String scheme() {
            return "alluxio";
        }

        @Override
        public Map<String, String> configMap() {
            final HashMap<String, String> map = new HashMap<>();
            if (root != null) {
                map.put("root", root);
            }
            if (endpoint != null) {
                map.put("endpoint", endpoint);
            }
            return map;
        }
    }

    /**
     * Configuration for service atomicserver.
     */
    @Builder
    @Data
    @RequiredArgsConstructor(access = AccessLevel.PRIVATE)
    class Atomicserver implements ServiceConfig {
        /**
         * <p>work dir of this backend</p>
         */
        private final String root;
        /**
         * <p>endpoint of this backend</p>
         */
        private final String endpoint;
        /**
         * <p>private_key of this backend</p>
         */
        private final String privateKey;
        /**
         * <p>public_key of this backend</p>
         */
        private final String publicKey;
        /**
         * <p>parent_resource_id of this backend</p>
         */
        private final String parentResourceId;

        @Override
        public String scheme() {
            return "atomicserver";
        }

        @Override
        public Map<String, String> configMap() {
            final HashMap<String, String> map = new HashMap<>();
            if (root != null) {
                map.put("root", root);
            }
            if (endpoint != null) {
                map.put("endpoint", endpoint);
            }
            if (privateKey != null) {
                map.put("private_key", privateKey);
            }
            if (publicKey != null) {
                map.put("public_key", publicKey);
            }
            if (parentResourceId != null) {
                map.put("parent_resource_id", parentResourceId);
            }
            return map;
        }
    }

    /**
     * Configuration for service azblob.
     */
    @Builder
    @Data
    @RequiredArgsConstructor(access = AccessLevel.PRIVATE)
    class Azblob implements ServiceConfig {
        /**
         * <p>The container name of Azblob service backend.</p>
         */
        private final @NonNull String container;
        /**
         * <p>The root of Azblob service backend.</p>
         * <p>All operations will happen under this root.</p>
         */
        private final String root;
        /**
         * <p>The endpoint of Azblob service backend.</p>
         * <p>Endpoint must be full uri, e.g.</p>
         * <ul>
         * <li>Azblob: <code>https://accountname.blob.core.windows.net</code></li>
         * <li>Azurite: <code>http://127.0.0.1:10000/devstoreaccount1</code></li>
         * </ul>
         */
        private final String endpoint;
        /**
         * <p>The account name of Azblob service backend.</p>
         */
        private final String accountName;
        /**
         * <p>The account key of Azblob service backend.</p>
         */
        private final String accountKey;
        /**
         * <p>The encryption key of Azblob service backend.</p>
         */
        private final String encryptionKey;
        /**
         * <p>The encryption key sha256 of Azblob service backend.</p>
         */
        private final String encryptionKeySha256;
        /**
         * <p>The encryption algorithm of Azblob service backend.</p>
         */
        private final String encryptionAlgorithm;
        /**
         * <p>The sas token of Azblob service backend.</p>
         */
        private final String sasToken;
        /**
         * <p>The maximum batch operations of Azblob service backend.</p>
         */
        private final Long batchMaxOperations;

        @Override
        public String scheme() {
            return "azblob";
        }

        @Override
        public Map<String, String> configMap() {
            final HashMap<String, String> map = new HashMap<>();
            map.put("container", container);
            if (root != null) {
                map.put("root", root);
            }
            if (endpoint != null) {
                map.put("endpoint", endpoint);
            }
            if (accountName != null) {
                map.put("account_name", accountName);
            }
            if (accountKey != null) {
                map.put("account_key", accountKey);
            }
            if (encryptionKey != null) {
                map.put("encryption_key", encryptionKey);
            }
            if (encryptionKeySha256 != null) {
                map.put("encryption_key_sha256", encryptionKeySha256);
            }
            if (encryptionAlgorithm != null) {
                map.put("encryption_algorithm", encryptionAlgorithm);
            }
            if (sasToken != null) {
                map.put("sas_token", sasToken);
            }
            if (batchMaxOperations != null) {
                map.put("batch_max_operations", String.valueOf(batchMaxOperations));
            }
            return map;
        }
    }

    /**
     * Configuration for service azdls.
     */
    @Builder
    @Data
    @RequiredArgsConstructor(access = AccessLevel.PRIVATE)
    class Azdls implements ServiceConfig {
        /**
         * <p>Filesystem name of this backend.</p>
         */
        private final @NonNull String filesystem;
        /**
         * <p>Root of this backend.</p>
         */
        private final String root;
        /**
         * <p>Endpoint of this backend.</p>
         */
        private final String endpoint;
        /**
         * <p>Account name of this backend.</p>
         */
        private final String accountName;
        /**
         * <p>Account key of this backend.</p>
         */
        private final String accountKey;

        @Override
        public String scheme() {
            return "azdls";
        }

        @Override
        public Map<String, String> configMap() {
            final HashMap<String, String> map = new HashMap<>();
            map.put("filesystem", filesystem);
            if (root != null) {
                map.put("root", root);
            }
            if (endpoint != null) {
                map.put("endpoint", endpoint);
            }
            if (accountName != null) {
                map.put("account_name", accountName);
            }
            if (accountKey != null) {
                map.put("account_key", accountKey);
            }
            return map;
        }
    }

    /**
     * Configuration for service azfile.
     */
    @Builder
    @Data
    @RequiredArgsConstructor(access = AccessLevel.PRIVATE)
    class Azfile implements ServiceConfig {
        /**
         * <p>The share name for azfile.</p>
         */
        private final @NonNull String shareName;
        /**
         * <p>The root path for azfile.</p>
         */
        private final String root;
        /**
         * <p>The endpoint for azfile.</p>
         */
        private final String endpoint;
        /**
         * <p>The account name for azfile.</p>
         */
        private final String accountName;
        /**
         * <p>The account key for azfile.</p>
         */
        private final String accountKey;
        /**
         * <p>The sas token for azfile.</p>
         */
        private final String sasToken;

        @Override
        public String scheme() {
            return "azfile";
        }

        @Override
        public Map<String, String> configMap() {
            final HashMap<String, String> map = new HashMap<>();
            map.put("share_name", shareName);
            if (root != null) {
                map.put("root", root);
            }
            if (endpoint != null) {
                map.put("endpoint", endpoint);
            }
            if (accountName != null) {
                map.put("account_name", accountName);
            }
            if (accountKey != null) {
                map.put("account_key", accountKey);
            }
            if (sasToken != null) {
                map.put("sas_token", sasToken);
            }
            return map;
        }
    }

    /**
     * Configuration for service b2.
     */
    @Builder
    @Data
    @RequiredArgsConstructor(access = AccessLevel.PRIVATE)
    class B2 implements ServiceConfig {
        /**
         * <p>bucket of this backend.</p>
         * <p>required.</p>
         */
        private final @NonNull String bucket;
        /**
         * <p>bucket id of this backend.</p>
         * <p>required.</p>
         */
        private final @NonNull String bucketId;
        /**
         * <p>root of this backend.</p>
         * <p>All operations will happen under this root.</p>
         */
        private final String root;
        /**
         * <p>keyID of this backend.</p>
         * <ul>
         * <li>If application_key_id is set, we will take user's input first.</li>
         * <li>If not, we will try to load it from environment.</li>
         * </ul>
         */
        private final String applicationKeyId;
        /**
         * <p>applicationKey of this backend.</p>
         * <ul>
         * <li>If application_key is set, we will take user's input first.</li>
         * <li>If not, we will try to load it from environment.</li>
         * </ul>
         */
        private final String applicationKey;

        @Override
        public String scheme() {
            return "b2";
        }

        @Override
        public Map<String, String> configMap() {
            final HashMap<String, String> map = new HashMap<>();
            map.put("bucket", bucket);
            map.put("bucket_id", bucketId);
            if (root != null) {
                map.put("root", root);
            }
            if (applicationKeyId != null) {
                map.put("application_key_id", applicationKeyId);
            }
            if (applicationKey != null) {
                map.put("application_key", applicationKey);
            }
            return map;
        }
    }

    /**
     * Configuration for service cacache.
     */
    @Builder
    @Data
    @RequiredArgsConstructor(access = AccessLevel.PRIVATE)
    class Cacache implements ServiceConfig {
        /**
         * <p>That path to the cacache data directory.</p>
         */
        private final String datadir;

        @Override
        public String scheme() {
            return "cacache";
        }

        @Override
        public Map<String, String> configMap() {
            final HashMap<String, String> map = new HashMap<>();
            if (datadir != null) {
                map.put("datadir", datadir);
            }
            return map;
        }
    }

    /**
     * Configuration for service chainsafe.
     */
    @Builder
    @Data
    @RequiredArgsConstructor(access = AccessLevel.PRIVATE)
    class Chainsafe implements ServiceConfig {
        /**
         * <p>bucket_id of this backend.</p>
         * <p>required.</p>
         */
        private final @NonNull String bucketId;
        /**
         * <p>root of this backend.</p>
         * <p>All operations will happen under this root.</p>
         */
        private final String root;
        /**
         * <p>api_key of this backend.</p>
         */
        private final String apiKey;

        @Override
        public String scheme() {
            return "chainsafe";
        }

        @Override
        public Map<String, String> configMap() {
            final HashMap<String, String> map = new HashMap<>();
            map.put("bucket_id", bucketId);
            if (root != null) {
                map.put("root", root);
            }
            if (apiKey != null) {
                map.put("api_key", apiKey);
            }
            return map;
        }
    }

    /**
     * Configuration for service cloudflare_kv.
     */
    @Builder
    @Data
    @RequiredArgsConstructor(access = AccessLevel.PRIVATE)
    class CloudflareKv implements ServiceConfig {
        /**
         * <p>The token used to authenticate with CloudFlare.</p>
         */
        private final String token;
        /**
         * <p>The account ID used to authenticate with CloudFlare. Used as URI path parameter.</p>
         */
        private final String accountId;
        /**
         * <p>The namespace ID. Used as URI path parameter.</p>
         */
        private final String namespaceId;
        /**
         * <p>Root within this backend.</p>
         */
        private final String root;

        @Override
        public String scheme() {
            return "cloudflare_kv";
        }

        @Override
        public Map<String, String> configMap() {
            final HashMap<String, String> map = new HashMap<>();
            if (token != null) {
                map.put("token", token);
            }
            if (accountId != null) {
                map.put("account_id", accountId);
            }
            if (namespaceId != null) {
                map.put("namespace_id", namespaceId);
            }
            if (root != null) {
                map.put("root", root);
            }
            return map;
        }
    }

    /**
     * Configuration for service compfs.
     */
    @Builder
    @Data
    @RequiredArgsConstructor(access = AccessLevel.PRIVATE)
    class Compfs implements ServiceConfig {
        /**
         * <p>root of this backend.</p>
         * <p>All operations will happen under this root.</p>
         */
        private final String root;

        @Override
        public String scheme() {
            return "compfs";
        }

        @Override
        public Map<String, String> configMap() {
            final HashMap<String, String> map = new HashMap<>();
            if (root != null) {
                map.put("root", root);
            }
            return map;
        }
    }

    /**
     * Configuration for service cos.
     */
    @Builder
    @Data
    @RequiredArgsConstructor(access = AccessLevel.PRIVATE)
    class Cos implements ServiceConfig {
        /**
         * <p>Root of this backend.</p>
         */
        private final String root;
        /**
         * <p>Endpoint of this backend.</p>
         */
        private final String endpoint;
        /**
         * <p>Secret ID of this backend.</p>
         */
        private final String secretId;
        /**
         * <p>Secret key of this backend.</p>
         */
        private final String secretKey;
        /**
         * <p>Bucket of this backend.</p>
         */
        private final String bucket;
        /**
         * <p>Disable config load so that opendal will not load config from</p>
         */
        private final Boolean disableConfigLoad;

        @Override
        public String scheme() {
            return "cos";
        }

        @Override
        public Map<String, String> configMap() {
            final HashMap<String, String> map = new HashMap<>();
            if (root != null) {
                map.put("root", root);
            }
            if (endpoint != null) {
                map.put("endpoint", endpoint);
            }
            if (secretId != null) {
                map.put("secret_id", secretId);
            }
            if (secretKey != null) {
                map.put("secret_key", secretKey);
            }
            if (bucket != null) {
                map.put("bucket", bucket);
            }
            if (disableConfigLoad != null) {
                map.put("disable_config_load", String.valueOf(disableConfigLoad));
            }
            return map;
        }
    }

    /**
     * Configuration for service d1.
     */
    @Builder
    @Data
    @RequiredArgsConstructor(access = AccessLevel.PRIVATE)
    class D1 implements ServiceConfig {
        /**
         * <p>Set the token of cloudflare api.</p>
         */
        private final String token;
        /**
         * <p>Set the account id of cloudflare api.</p>
         */
        private final String accountId;
        /**
         * <p>Set the database id of cloudflare api.</p>
         */
        private final String databaseId;
        /**
         * <p>Set the working directory of OpenDAL.</p>
         */
        private final String root;
        /**
         * <p>Set the table of D1 Database.</p>
         */
        private final String table;
        /**
         * <p>Set the key field of D1 Database.</p>
         */
        private final String keyField;
        /**
         * <p>Set the value field of D1 Database.</p>
         */
        private final String valueField;

        @Override
        public String scheme() {
            return "d1";
        }

        @Override
        public Map<String, String> configMap() {
            final HashMap<String, String> map = new HashMap<>();
            if (token != null) {
                map.put("token", token);
            }
            if (accountId != null) {
                map.put("account_id", accountId);
            }
            if (databaseId != null) {
                map.put("database_id", databaseId);
            }
            if (root != null) {
                map.put("root", root);
            }
            if (table != null) {
                map.put("table", table);
            }
            if (keyField != null) {
                map.put("key_field", keyField);
            }
            if (valueField != null) {
                map.put("value_field", valueField);
            }
            return map;
        }
    }

    /**
     * Configuration for service dashmap.
     */
    @Builder
    @Data
    @RequiredArgsConstructor(access = AccessLevel.PRIVATE)
    class Dashmap implements ServiceConfig {
        /**
         * <p>The root path for dashmap.</p>
         */
        private final String root;

        @Override
        public String scheme() {
            return "dashmap";
        }

        @Override
        public Map<String, String> configMap() {
            final HashMap<String, String> map = new HashMap<>();
            if (root != null) {
                map.put("root", root);
            }
            return map;
        }
    }

    /**
     * Configuration for service dbfs.
     */
    @Builder
    @Data
    @RequiredArgsConstructor(access = AccessLevel.PRIVATE)
    class Dbfs implements ServiceConfig {
        /**
         * <p>The root for dbfs.</p>
         */
        private final String root;
        /**
         * <p>The endpoint for dbfs.</p>
         */
        private final String endpoint;
        /**
         * <p>The token for dbfs.</p>
         */
        private final String token;

        @Override
        public String scheme() {
            return "dbfs";
        }

        @Override
        public Map<String, String> configMap() {
            final HashMap<String, String> map = new HashMap<>();
            if (root != null) {
                map.put("root", root);
            }
            if (endpoint != null) {
                map.put("endpoint", endpoint);
            }
            if (token != null) {
                map.put("token", token);
            }
            return map;
        }
    }

    /**
     * Configuration for service dropbox.
     */
    @Builder
    @Data
    @RequiredArgsConstructor(access = AccessLevel.PRIVATE)
    class Dropbox implements ServiceConfig {
        /**
         * <p>root path for dropbox.</p>
         */
        private final String root;
        /**
         * <p>access token for dropbox.</p>
         */
        private final String accessToken;
        /**
         * <p>refresh_token for dropbox.</p>
         */
        private final String refreshToken;
        /**
         * <p>client_id for dropbox.</p>
         */
        private final String clientId;
        /**
         * <p>client_secret for dropbox.</p>
         */
        private final String clientSecret;

        @Override
        public String scheme() {
            return "dropbox";
        }

        @Override
        public Map<String, String> configMap() {
            final HashMap<String, String> map = new HashMap<>();
            if (root != null) {
                map.put("root", root);
            }
            if (accessToken != null) {
                map.put("access_token", accessToken);
            }
            if (refreshToken != null) {
                map.put("refresh_token", refreshToken);
            }
            if (clientId != null) {
                map.put("client_id", clientId);
            }
            if (clientSecret != null) {
                map.put("client_secret", clientSecret);
            }
            return map;
        }
    }

    /**
     * Configuration for service etcd.
     */
    @Builder
    @Data
    @RequiredArgsConstructor(access = AccessLevel.PRIVATE)
    class Etcd implements ServiceConfig {
        /**
         * <p>network address of the Etcd services.
         * If use https, must set TLS options: <code>ca_path</code>, <code>cert_path</code>, <code>key_path</code>.
         * e.g. &quot;127.0.0.1:23790,127.0.0.1:23791,127.0.0.1:23792&quot; or &quot;http://127.0.0.1:23790,http://127.0.0.1:23791,http://127.0.0.1:23792&quot; or &quot;https://127.0.0.1:23790,https://127.0.0.1:23791,https://127.0.0.1:23792&quot;</p>
         * <p>default is &quot;http://127.0.0.1:2379&quot;</p>
         */
        private final String endpoints;
        /**
         * <p>the username to connect etcd service.</p>
         * <p>default is None</p>
         */
        private final String username;
        /**
         * <p>the password for authentication</p>
         * <p>default is None</p>
         */
        private final String password;
        /**
         * <p>the working directory of the etcd service. Can be &quot;/path/to/dir&quot;</p>
         * <p>default is &quot;/&quot;</p>
         */
        private final String root;
        /**
         * <p>certificate authority file path</p>
         * <p>default is None</p>
         */
        private final String caPath;
        /**
         * <p>cert path</p>
         * <p>default is None</p>
         */
        private final String certPath;
        /**
         * <p>key path</p>
         * <p>default is None</p>
         */
        private final String keyPath;

        @Override
        public String scheme() {
            return "etcd";
        }

        @Override
        public Map<String, String> configMap() {
            final HashMap<String, String> map = new HashMap<>();
            if (endpoints != null) {
                map.put("endpoints", endpoints);
            }
            if (username != null) {
                map.put("username", username);
            }
            if (password != null) {
                map.put("password", password);
            }
            if (root != null) {
                map.put("root", root);
            }
            if (caPath != null) {
                map.put("ca_path", caPath);
            }
            if (certPath != null) {
                map.put("cert_path", certPath);
            }
            if (keyPath != null) {
                map.put("key_path", keyPath);
            }
            return map;
        }
    }

    /**
     * Configuration for service fs.
     */
    @Builder
    @Data
    @RequiredArgsConstructor(access = AccessLevel.PRIVATE)
    class Fs implements ServiceConfig {
        /**
         * <p>root dir for backend</p>
         */
        private final String root;
        /**
         * <p>tmp dir for atomic write</p>
         */
        private final String atomicWriteDir;

        @Override
        public String scheme() {
            return "fs";
        }

        @Override
        public Map<String, String> configMap() {
            final HashMap<String, String> map = new HashMap<>();
            if (root != null) {
                map.put("root", root);
            }
            if (atomicWriteDir != null) {
                map.put("atomic_write_dir", atomicWriteDir);
            }
            return map;
        }
    }

    /**
     * Configuration for service gcs.
     */
    @Builder
    @Data
    @RequiredArgsConstructor(access = AccessLevel.PRIVATE)
    class Gcs implements ServiceConfig {
        /**
         * <p>bucket name</p>
         */
        private final @NonNull String bucket;
        /**
         * <p>root URI, all operations happens under <code>root</code></p>
         */
        private final String root;
        /**
         * <p>endpoint URI of GCS service,
         * default is <code>https://storage.googleapis.com</code></p>
         */
        private final String endpoint;
        /**
         * <p>Scope for gcs.</p>
         */
        private final String scope;
        /**
         * <p>Service Account for gcs.</p>
         */
        private final String serviceAccount;
        /**
         * <p>Credentials string for GCS service OAuth2 authentication.</p>
         */
        private final String credential;
        /**
         * <p>Local path to credentials file for GCS service OAuth2 authentication.</p>
         */
        private final String credentialPath;
        /**
         * <p>The predefined acl for GCS.</p>
         */
        private final String predefinedAcl;
        /**
         * <p>The default storage class used by gcs.</p>
         */
        private final String defaultStorageClass;
        /**
         * <p>Allow opendal to send requests without signing when credentials are not
         * loaded.</p>
         */
        private final Boolean allowAnonymous;
        /**
         * <p>Disable attempting to load credentials from the GCE metadata server when
         * running within Google Cloud.</p>
         */
        private final Boolean disableVmMetadata;
        /**
         * <p>Disable loading configuration from the environment.</p>
         */
        private final Boolean disableConfigLoad;
        /**
         * <p>A Google Cloud OAuth2 token.</p>
         * <p>Takes precedence over <code>credential</code> and <code>credential_path</code>.</p>
         */
        private final String token;

        @Override
        public String scheme() {
            return "gcs";
        }

        @Override
        public Map<String, String> configMap() {
            final HashMap<String, String> map = new HashMap<>();
            map.put("bucket", bucket);
            if (root != null) {
                map.put("root", root);
            }
            if (endpoint != null) {
                map.put("endpoint", endpoint);
            }
            if (scope != null) {
                map.put("scope", scope);
            }
            if (serviceAccount != null) {
                map.put("service_account", serviceAccount);
            }
            if (credential != null) {
                map.put("credential", credential);
            }
            if (credentialPath != null) {
                map.put("credential_path", credentialPath);
            }
            if (predefinedAcl != null) {
                map.put("predefined_acl", predefinedAcl);
            }
            if (defaultStorageClass != null) {
                map.put("default_storage_class", defaultStorageClass);
            }
            if (allowAnonymous != null) {
                map.put("allow_anonymous", String.valueOf(allowAnonymous));
            }
            if (disableVmMetadata != null) {
                map.put("disable_vm_metadata", String.valueOf(disableVmMetadata));
            }
            if (disableConfigLoad != null) {
                map.put("disable_config_load", String.valueOf(disableConfigLoad));
            }
            if (token != null) {
                map.put("token", token);
            }
            return map;
        }
    }

    /**
     * Configuration for service gdrive.
     */
    @Builder
    @Data
    @RequiredArgsConstructor(access = AccessLevel.PRIVATE)
    class Gdrive implements ServiceConfig {
        /**
         * <p>The root for gdrive</p>
         */
        private final String root;
        /**
         * <p>Access token for gdrive.</p>
         */
        private final String accessToken;
        /**
         * <p>Refresh token for gdrive.</p>
         */
        private final String refreshToken;
        /**
         * <p>Client id for gdrive.</p>
         */
        private final String clientId;
        /**
         * <p>Client secret for gdrive.</p>
         */
        private final String clientSecret;

        @Override
        public String scheme() {
            return "gdrive";
        }

        @Override
        public Map<String, String> configMap() {
            final HashMap<String, String> map = new HashMap<>();
            if (root != null) {
                map.put("root", root);
            }
            if (accessToken != null) {
                map.put("access_token", accessToken);
            }
            if (refreshToken != null) {
                map.put("refresh_token", refreshToken);
            }
            if (clientId != null) {
                map.put("client_id", clientId);
            }
            if (clientSecret != null) {
                map.put("client_secret", clientSecret);
            }
            return map;
        }
    }

    /**
     * Configuration for service ghac.
     */
    @Builder
    @Data
    @RequiredArgsConstructor(access = AccessLevel.PRIVATE)
    class Ghac implements ServiceConfig {
        /**
         * <p>The root path for ghac.</p>
         */
        private final String root;
        /**
         * <p>The version that used by cache.</p>
         */
        private final String version;
        /**
         * <p>The endpoint for ghac service.</p>
         */
        private final String endpoint;
        /**
         * <p>The runtime token for ghac service.</p>
         */
        private final String runtimeToken;

        @Override
        public String scheme() {
            return "ghac";
        }

        @Override
        public Map<String, String> configMap() {
            final HashMap<String, String> map = new HashMap<>();
            if (root != null) {
                map.put("root", root);
            }
            if (version != null) {
                map.put("version", version);
            }
            if (endpoint != null) {
                map.put("endpoint", endpoint);
            }
            if (runtimeToken != null) {
                map.put("runtime_token", runtimeToken);
            }
            return map;
        }
    }

    /**
     * Configuration for service github.
     */
    @Builder
    @Data
    @RequiredArgsConstructor(access = AccessLevel.PRIVATE)
    class Github implements ServiceConfig {
        /**
         * <p>GitHub repo owner.</p>
         * <p>required.</p>
         */
        private final @NonNull String owner;
        /**
         * <p>GitHub repo name.</p>
         * <p>required.</p>
         */
        private final @NonNull String repo;
        /**
         * <p>root of this backend.</p>
         * <p>All operations will happen under this root.</p>
         */
        private final String root;
        /**
         * <p>GitHub access_token.</p>
         * <p>optional.
         * If not provided, the backend will only support read operations for public repositories.
         * And rate limit will be limited to 60 requests per hour.</p>
         */
        private final String token;

        @Override
        public String scheme() {
            return "github";
        }

        @Override
        public Map<String, String> configMap() {
            final HashMap<String, String> map = new HashMap<>();
            map.put("owner", owner);
            map.put("repo", repo);
            if (root != null) {
                map.put("root", root);
            }
            if (token != null) {
                map.put("token", token);
            }
            return map;
        }
    }

    /**
     * Configuration for service gridfs.
     */
    @Builder
    @Data
    @RequiredArgsConstructor(access = AccessLevel.PRIVATE)
    class Gridfs implements ServiceConfig {
        /**
         * <p>The connection string of the MongoDB service.</p>
         */
        private final String connectionString;
        /**
         * <p>The database name of the MongoDB GridFs service to read/write.</p>
         */
        private final String database;
        /**
         * <p>The bucket name of the MongoDB GridFs service to read/write.</p>
         */
        private final String bucket;
        /**
         * <p>The chunk size of the MongoDB GridFs service used to break the user file into chunks.</p>
         */
        private final Integer chunkSize;
        /**
         * <p>The working directory, all operations will be performed under it.</p>
         */
        private final String root;

        @Override
        public String scheme() {
            return "gridfs";
        }

        @Override
        public Map<String, String> configMap() {
            final HashMap<String, String> map = new HashMap<>();
            if (connectionString != null) {
                map.put("connection_string", connectionString);
            }
            if (database != null) {
                map.put("database", database);
            }
            if (bucket != null) {
                map.put("bucket", bucket);
            }
            if (chunkSize != null) {
                map.put("chunk_size", String.valueOf(chunkSize));
            }
            if (root != null) {
                map.put("root", root);
            }
            return map;
        }
    }

    /**
     * Configuration for service hdfs_native.
     */
    @Builder
    @Data
    @RequiredArgsConstructor(access = AccessLevel.PRIVATE)
    class HdfsNative implements ServiceConfig {
        /**
         * <p>work dir of this backend</p>
         */
        private final String root;
        /**
         * <p>url of this backend</p>
         */
        private final String url;
        /**
         * <p>enable the append capacity</p>
         */
        private final Boolean enableAppend;

        @Override
        public String scheme() {
            return "hdfs_native";
        }

        @Override
        public Map<String, String> configMap() {
            final HashMap<String, String> map = new HashMap<>();
            if (root != null) {
                map.put("root", root);
            }
            if (url != null) {
                map.put("url", url);
            }
            if (enableAppend != null) {
                map.put("enable_append", String.valueOf(enableAppend));
            }
            return map;
        }
    }

    /**
     * Configuration for service http.
     */
    @Builder
    @Data
    @RequiredArgsConstructor(access = AccessLevel.PRIVATE)
    class Http implements ServiceConfig {
        /**
         * <p>endpoint of this backend</p>
         */
        private final String endpoint;
        /**
         * <p>username of this backend</p>
         */
        private final String username;
        /**
         * <p>password of this backend</p>
         */
        private final String password;
        /**
         * <p>token of this backend</p>
         */
        private final String token;
        /**
         * <p>root of this backend</p>
         */
        private final String root;

        @Override
        public String scheme() {
            return "http";
        }

        @Override
        public Map<String, String> configMap() {
            final HashMap<String, String> map = new HashMap<>();
            if (endpoint != null) {
                map.put("endpoint", endpoint);
            }
            if (username != null) {
                map.put("username", username);
            }
            if (password != null) {
                map.put("password", password);
            }
            if (token != null) {
                map.put("token", token);
            }
            if (root != null) {
                map.put("root", root);
            }
            return map;
        }
    }

    /**
     * Configuration for service huggingface.
     */
    @Builder
    @Data
    @RequiredArgsConstructor(access = AccessLevel.PRIVATE)
    class Huggingface implements ServiceConfig {
        /**
         * <p>Repo type of this backend. Default is model.</p>
         * <p>Available values:</p>
         * <ul>
         * <li>model</li>
         * <li>dataset</li>
         * </ul>
         */
        private final String repoType;
        /**
         * <p>Repo id of this backend.</p>
         * <p>This is required.</p>
         */
        private final String repoId;
        /**
         * <p>Revision of this backend.</p>
         * <p>Default is main.</p>
         */
        private final String revision;
        /**
         * <p>Root of this backend. Can be &quot;/path/to/dir&quot;.</p>
         * <p>Default is &quot;/&quot;.</p>
         */
        private final String root;
        /**
         * <p>Token of this backend.</p>
         * <p>This is optional.</p>
         */
        private final String token;

        @Override
        public String scheme() {
            return "huggingface";
        }

        @Override
        public Map<String, String> configMap() {
            final HashMap<String, String> map = new HashMap<>();
            if (repoType != null) {
                map.put("repo_type", repoType);
            }
            if (repoId != null) {
                map.put("repo_id", repoId);
            }
            if (revision != null) {
                map.put("revision", revision);
            }
            if (root != null) {
                map.put("root", root);
            }
            if (token != null) {
                map.put("token", token);
            }
            return map;
        }
    }

    /**
     * Configuration for service icloud.
     */
    @Builder
    @Data
    @RequiredArgsConstructor(access = AccessLevel.PRIVATE)
    class Icloud implements ServiceConfig {
        /**
         * <p>root of this backend.</p>
         * <p>All operations will happen under this root.</p>
         * <p>default to <code>/</code> if not set.</p>
         */
        private final String root;
        /**
         * <p>apple_id of this backend.</p>
         * <p>apple_id must be full, mostly like <code>example@gmail.com</code>.</p>
         */
        private final String appleId;
        /**
         * <p>password of this backend.</p>
         * <p>password must be full.</p>
         */
        private final String password;
        /**
         * <p>Session</p>
         * <p>token must be valid.</p>
         */
        private final String trustToken;
        /**
         * <p>ds_web_auth_token must be set in Session</p>
         */
        private final String dsWebAuthToken;
        /**
         * <p>enable the china origin
         * China region <code>origin</code> Header needs to be set to &quot;https://www.icloud.com.cn&quot;.</p>
         * <p>otherwise Apple server will return 302.</p>
         */
        private final Boolean isChinaMainland;

        @Override
        public String scheme() {
            return "icloud";
        }

        @Override
        public Map<String, String> configMap() {
            final HashMap<String, String> map = new HashMap<>();
            if (root != null) {
                map.put("root", root);
            }
            if (appleId != null) {
                map.put("apple_id", appleId);
            }
            if (password != null) {
                map.put("password", password);
            }
            if (trustToken != null) {
                map.put("trust_token", trustToken);
            }
            if (dsWebAuthToken != null) {
                map.put("ds_web_auth_token", dsWebAuthToken);
            }
            if (isChinaMainland != null) {
                map.put("is_china_mainland", String.valueOf(isChinaMainland));
            }
            return map;
        }
    }

    /**
     * Configuration for service ipfs.
     */
    @Builder
    @Data
    @RequiredArgsConstructor(access = AccessLevel.PRIVATE)
    class Ipfs implements ServiceConfig {
        /**
         * <p>IPFS gateway endpoint.</p>
         */
        private final String endpoint;
        /**
         * <p>IPFS root.</p>
         */
        private final String root;

        @Override
        public String scheme() {
            return "ipfs";
        }

        @Override
        public Map<String, String> configMap() {
            final HashMap<String, String> map = new HashMap<>();
            if (endpoint != null) {
                map.put("endpoint", endpoint);
            }
            if (root != null) {
                map.put("root", root);
            }
            return map;
        }
    }

    /**
     * Configuration for service ipmfs.
     */
    @Builder
    @Data
    @RequiredArgsConstructor(access = AccessLevel.PRIVATE)
    class Ipmfs implements ServiceConfig {
        /**
         * <p>Root for ipfs.</p>
         */
        private final String root;
        /**
         * <p>Endpoint for ipfs.</p>
         */
        private final String endpoint;

        @Override
        public String scheme() {
            return "ipmfs";
        }

        @Override
        public Map<String, String> configMap() {
            final HashMap<String, String> map = new HashMap<>();
            if (root != null) {
                map.put("root", root);
            }
            if (endpoint != null) {
                map.put("endpoint", endpoint);
            }
            return map;
        }
    }

    /**
     * Configuration for service koofr.
     */
    @Builder
    @Data
    @RequiredArgsConstructor(access = AccessLevel.PRIVATE)
    class Koofr implements ServiceConfig {
        /**
         * <p>Koofr endpoint.</p>
         */
        private final @NonNull String endpoint;
        /**
         * <p>Koofr email.</p>
         */
        private final @NonNull String email;
        /**
         * <p>root of this backend.</p>
         * <p>All operations will happen under this root.</p>
         */
        private final String root;
        /**
         * <p>password of this backend. (Must be the application password)</p>
         */
        private final String password;

        @Override
        public String scheme() {
            return "koofr";
        }

        @Override
        public Map<String, String> configMap() {
            final HashMap<String, String> map = new HashMap<>();
            map.put("endpoint", endpoint);
            map.put("email", email);
            if (root != null) {
                map.put("root", root);
            }
            if (password != null) {
                map.put("password", password);
            }
            return map;
        }
    }

    /**
     * Configuration for service lakefs.
     */
    @Builder
    @Data
    @RequiredArgsConstructor(access = AccessLevel.PRIVATE)
    class Lakefs implements ServiceConfig {
        /**
         * <p>Base url.</p>
         * <p>This is required.</p>
         */
        private final String endpoint;
        /**
         * <p>Username for Lakefs basic authentication.</p>
         * <p>This is required.</p>
         */
        private final String username;
        /**
         * <p>Password for Lakefs basic authentication.</p>
         * <p>This is required.</p>
         */
        private final String password;
        /**
         * <p>Root of this backend. Can be &quot;/path/to/dir&quot;.</p>
         * <p>Default is &quot;/&quot;.</p>
         */
        private final String root;
        /**
         * <p>The repository name</p>
         * <p>This is required.</p>
         */
        private final String repository;
        /**
         * <p>Name of the branch or a commit ID. Default is main.</p>
         * <p>This is optional.</p>
         */
        private final String branch;

        @Override
        public String scheme() {
            return "lakefs";
        }

        @Override
        public Map<String, String> configMap() {
            final HashMap<String, String> map = new HashMap<>();
            if (endpoint != null) {
                map.put("endpoint", endpoint);
            }
            if (username != null) {
                map.put("username", username);
            }
            if (password != null) {
                map.put("password", password);
            }
            if (root != null) {
                map.put("root", root);
            }
            if (repository != null) {
                map.put("repository", repository);
            }
            if (branch != null) {
                map.put("branch", branch);
            }
            return map;
        }
    }

    /**
     * Configuration for service libsql.
     */
    @Builder
    @Data
    @RequiredArgsConstructor(access = AccessLevel.PRIVATE)
    class Libsql implements ServiceConfig {
        /**
         * <p>Connection string for libsql service.</p>
         */
        private final String connectionString;
        /**
         * <p>Authentication token for libsql service.</p>
         */
        private final String authToken;
        /**
         * <p>Table name for libsql service.</p>
         */
        private final String table;
        /**
         * <p>Key field name for libsql service.</p>
         */
        private final String keyField;
        /**
         * <p>Value field name for libsql service.</p>
         */
        private final String valueField;
        /**
         * <p>Root for libsql service.</p>
         */
        private final String root;

        @Override
        public String scheme() {
            return "libsql";
        }

        @Override
        public Map<String, String> configMap() {
            final HashMap<String, String> map = new HashMap<>();
            if (connectionString != null) {
                map.put("connection_string", connectionString);
            }
            if (authToken != null) {
                map.put("auth_token", authToken);
            }
            if (table != null) {
                map.put("table", table);
            }
            if (keyField != null) {
                map.put("key_field", keyField);
            }
            if (valueField != null) {
                map.put("value_field", valueField);
            }
            if (root != null) {
                map.put("root", root);
            }
            return map;
        }
    }

    /**
     * Configuration for service memcached.
     */
    @Builder
    @Data
    @RequiredArgsConstructor(access = AccessLevel.PRIVATE)
    class Memcached implements ServiceConfig {
        /**
         * <p>network address of the memcached service.</p>
         * <p>For example: &quot;tcp://localhost:11211&quot;</p>
         */
        private final String endpoint;
        /**
         * <p>the working directory of the service. Can be &quot;/path/to/dir&quot;</p>
         * <p>default is &quot;/&quot;</p>
         */
        private final String root;
        /**
         * <p>Memcached username, optional.</p>
         */
        private final String username;
        /**
         * <p>Memcached password, optional.</p>
         */
        private final String password;
        /**
         * <p>The default ttl for put operations.</p>
         */
        private final Duration defaultTtl;

        @Override
        public String scheme() {
            return "memcached";
        }

        @Override
        public Map<String, String> configMap() {
            final HashMap<String, String> map = new HashMap<>();
            if (endpoint != null) {
                map.put("endpoint", endpoint);
            }
            if (root != null) {
                map.put("root", root);
            }
            if (username != null) {
                map.put("username", username);
            }
            if (password != null) {
                map.put("password", password);
            }
            if (defaultTtl != null) {
                map.put("default_ttl", defaultTtl.toString());
            }
            return map;
        }
    }

    /**
     * Configuration for service memory.
     */
    @Builder
    @Data
    @RequiredArgsConstructor(access = AccessLevel.PRIVATE)
    class Memory implements ServiceConfig {
        /**
         * <p>root of the backend.</p>
         */
        private final String root;

        @Override
        public String scheme() {
            return "memory";
        }

        @Override
        public Map<String, String> configMap() {
            final HashMap<String, String> map = new HashMap<>();
            if (root != null) {
                map.put("root", root);
            }
            return map;
        }
    }

    /**
     * Configuration for service mini_moka.
     */
    @Builder
    @Data
    @RequiredArgsConstructor(access = AccessLevel.PRIVATE)
    class MiniMoka implements ServiceConfig {
        /**
         * <p>Sets the max capacity of the cache.</p>
         * <p>Refer to <a href="https://docs.rs/mini-moka/latest/mini_moka/sync/struct.CacheBuilder.html#method.max_capacity"><code>mini-moka::sync::CacheBuilder::max_capacity</code></a></p>
         */
        private final Long maxCapacity;
        /**
         * <p>Sets the time to live of the cache.</p>
         * <p>Refer to <a href="https://docs.rs/mini-moka/latest/mini_moka/sync/struct.CacheBuilder.html#method.time_to_live"><code>mini-moka::sync::CacheBuilder::time_to_live</code></a></p>
         */
        private final Duration timeToLive;
        /**
         * <p>Sets the time to idle of the cache.</p>
         * <p>Refer to <a href="https://docs.rs/mini-moka/latest/mini_moka/sync/struct.CacheBuilder.html#method.time_to_idle"><code>mini-moka::sync::CacheBuilder::time_to_idle</code></a></p>
         */
        private final Duration timeToIdle;
        /**
         * <p>root path of this backend</p>
         */
        private final String root;

        @Override
        public String scheme() {
            return "mini_moka";
        }

        @Override
        public Map<String, String> configMap() {
            final HashMap<String, String> map = new HashMap<>();
            if (maxCapacity != null) {
                map.put("max_capacity", String.valueOf(maxCapacity));
            }
            if (timeToLive != null) {
                map.put("time_to_live", timeToLive.toString());
            }
            if (timeToIdle != null) {
                map.put("time_to_idle", timeToIdle.toString());
            }
            if (root != null) {
                map.put("root", root);
            }
            return map;
        }
    }

    /**
     * Configuration for service moka.
     */
    @Builder
    @Data
    @RequiredArgsConstructor(access = AccessLevel.PRIVATE)
    class Moka implements ServiceConfig {
        /**
         * <p>Name for this cache instance.</p>
         */
        private final String name;
        /**
         * <p>Sets the max capacity of the cache.</p>
         * <p>Refer to <a href="https://docs.rs/moka/latest/moka/sync/struct.CacheBuilder.html#method.max_capacity"><code>moka::sync::CacheBuilder::max_capacity</code></a></p>
         */
        private final Long maxCapacity;
        /**
         * <p>Sets the time to live of the cache.</p>
         * <p>Refer to <a href="https://docs.rs/moka/latest/moka/sync/struct.CacheBuilder.html#method.time_to_live"><code>moka::sync::CacheBuilder::time_to_live</code></a></p>
         */
        private final Duration timeToLive;
        /**
         * <p>Sets the time to idle of the cache.</p>
         * <p>Refer to <a href="https://docs.rs/moka/latest/moka/sync/struct.CacheBuilder.html#method.time_to_idle"><code>moka::sync::CacheBuilder::time_to_idle</code></a></p>
         */
        private final Duration timeToIdle;
        /**
         * <p>Sets the segments number of the cache.</p>
         * <p>Refer to <a href="https://docs.rs/moka/latest/moka/sync/struct.CacheBuilder.html#method.segments"><code>moka::sync::CacheBuilder::segments</code></a></p>
         */
        private final Long numSegments;
        /**
         * <p>root path of this backend</p>
         */
        private final String root;

        @Override
        public String scheme() {
            return "moka";
        }

        @Override
        public Map<String, String> configMap() {
            final HashMap<String, String> map = new HashMap<>();
            if (name != null) {
                map.put("name", name);
            }
            if (maxCapacity != null) {
                map.put("max_capacity", String.valueOf(maxCapacity));
            }
            if (timeToLive != null) {
                map.put("time_to_live", timeToLive.toString());
            }
            if (timeToIdle != null) {
                map.put("time_to_idle", timeToIdle.toString());
            }
            if (numSegments != null) {
                map.put("num_segments", String.valueOf(numSegments));
            }
            if (root != null) {
                map.put("root", root);
            }
            return map;
        }
    }

    /**
     * Configuration for service mongodb.
     */
    @Builder
    @Data
    @RequiredArgsConstructor(access = AccessLevel.PRIVATE)
    class Mongodb implements ServiceConfig {
        /**
         * <p>connection string of this backend</p>
         */
        private final String connectionString;
        /**
         * <p>database of this backend</p>
         */
        private final String database;
        /**
         * <p>collection of this backend</p>
         */
        private final String collection;
        /**
         * <p>root of this backend</p>
         */
        private final String root;
        /**
         * <p>key field of this backend</p>
         */
        private final String keyField;
        /**
         * <p>value field of this backend</p>
         */
        private final String valueField;

        @Override
        public String scheme() {
            return "mongodb";
        }

        @Override
        public Map<String, String> configMap() {
            final HashMap<String, String> map = new HashMap<>();
            if (connectionString != null) {
                map.put("connection_string", connectionString);
            }
            if (database != null) {
                map.put("database", database);
            }
            if (collection != null) {
                map.put("collection", collection);
            }
            if (root != null) {
                map.put("root", root);
            }
            if (keyField != null) {
                map.put("key_field", keyField);
            }
            if (valueField != null) {
                map.put("value_field", valueField);
            }
            return map;
        }
    }

    /**
     * Configuration for service monoiofs.
     */
    @Builder
    @Data
    @RequiredArgsConstructor(access = AccessLevel.PRIVATE)
    class Monoiofs implements ServiceConfig {
        /**
         * <p>The Root of this backend.</p>
         * <p>All operations will happen under this root.</p>
         * <p>Builder::build will return error if not set.</p>
         */
        private final String root;

        @Override
        public String scheme() {
            return "monoiofs";
        }

        @Override
        public Map<String, String> configMap() {
            final HashMap<String, String> map = new HashMap<>();
            if (root != null) {
                map.put("root", root);
            }
            return map;
        }
    }

    /**
     * Configuration for service mysql.
     */
    @Builder
    @Data
    @RequiredArgsConstructor(access = AccessLevel.PRIVATE)
    class Mysql implements ServiceConfig {
        /**
         * <p>This connection string is used to connect to the mysql service. There are url based formats:</p>
         * <h2>Url</h2>
         * <p>This format resembles the url format of the mysql client. The format is: <code>[scheme://][user[:[password]]@]host[:port][/schema][?attribute1=value1&amp;attribute2=value2...</code></p>
         * <ul>
         * <li><code>mysql://user@localhost</code></li>
         * <li><code>mysql://user:password@localhost</code></li>
         * <li><code>mysql://user:password@localhost:3306</code></li>
         * <li><code>mysql://user:password@localhost:3306/db</code></li>
         * </ul>
         * <p>For more information, please refer to <a href="https://docs.rs/sqlx/latest/sqlx/mysql/struct.MySqlConnectOptions.html">https://docs.rs/sqlx/latest/sqlx/mysql/struct.MySqlConnectOptions.html</a>.</p>
         */
        private final String connectionString;
        /**
         * <p>The table name for mysql.</p>
         */
        private final String table;
        /**
         * <p>The key field name for mysql.</p>
         */
        private final String keyField;
        /**
         * <p>The value field name for mysql.</p>
         */
        private final String valueField;
        /**
         * <p>The root for mysql.</p>
         */
        private final String root;

        @Override
        public String scheme() {
            return "mysql";
        }

        @Override
        public Map<String, String> configMap() {
            final HashMap<String, String> map = new HashMap<>();
            if (connectionString != null) {
                map.put("connection_string", connectionString);
            }
            if (table != null) {
                map.put("table", table);
            }
            if (keyField != null) {
                map.put("key_field", keyField);
            }
            if (valueField != null) {
                map.put("value_field", valueField);
            }
            if (root != null) {
                map.put("root", root);
            }
            return map;
        }
    }

    /**
     * Configuration for service nebula_graph.
     */
    @Builder
    @Data
    @RequiredArgsConstructor(access = AccessLevel.PRIVATE)
    class NebulaGraph implements ServiceConfig {
        /**
         * <p>The host addr of nebulagraph's graphd server</p>
         */
        private final String host;
        /**
         * <p>The host port of nebulagraph's graphd server</p>
         */
        private final Integer port;
        /**
         * <p>The username of nebulagraph's graphd server</p>
         */
        private final String username;
        /**
         * <p>The password of nebulagraph's graphd server</p>
         */
        private final String password;
        /**
         * <p>The space name of nebulagraph's graphd server</p>
         */
        private final String space;
        /**
         * <p>The tag name of nebulagraph's graphd server</p>
         */
        private final String tag;
        /**
         * <p>The key field name of the NebulaGraph service to read/write.</p>
         */
        private final String keyField;
        /**
         * <p>The value field name of the NebulaGraph service to read/write.</p>
         */
        private final String valueField;
        /**
         * <p>The root for NebulaGraph</p>
         */
        private final String root;

        @Override
        public String scheme() {
            return "nebula_graph";
        }

        @Override
        public Map<String, String> configMap() {
            final HashMap<String, String> map = new HashMap<>();
            if (host != null) {
                map.put("host", host);
            }
            if (port != null) {
                map.put("port", String.valueOf(port));
            }
            if (username != null) {
                map.put("username", username);
            }
            if (password != null) {
                map.put("password", password);
            }
            if (space != null) {
                map.put("space", space);
            }
            if (tag != null) {
                map.put("tag", tag);
            }
            if (keyField != null) {
                map.put("key_field", keyField);
            }
            if (valueField != null) {
                map.put("value_field", valueField);
            }
            if (root != null) {
                map.put("root", root);
            }
            return map;
        }
    }

    /**
     * Configuration for service obs.
     */
    @Builder
    @Data
    @RequiredArgsConstructor(access = AccessLevel.PRIVATE)
    class Obs implements ServiceConfig {
        /**
         * <p>Root for obs.</p>
         */
        private final String root;
        /**
         * <p>Endpoint for obs.</p>
         */
        private final String endpoint;
        /**
         * <p>Access key id for obs.</p>
         */
        private final String accessKeyId;
        /**
         * <p>Secret access key for obs.</p>
         */
        private final String secretAccessKey;
        /**
         * <p>Bucket for obs.</p>
         */
        private final String bucket;

        @Override
        public String scheme() {
            return "obs";
        }

        @Override
        public Map<String, String> configMap() {
            final HashMap<String, String> map = new HashMap<>();
            if (root != null) {
                map.put("root", root);
            }
            if (endpoint != null) {
                map.put("endpoint", endpoint);
            }
            if (accessKeyId != null) {
                map.put("access_key_id", accessKeyId);
            }
            if (secretAccessKey != null) {
                map.put("secret_access_key", secretAccessKey);
            }
            if (bucket != null) {
                map.put("bucket", bucket);
            }
            return map;
        }
    }

    /**
     * Configuration for service onedrive.
     */
    @Builder
    @Data
    @RequiredArgsConstructor(access = AccessLevel.PRIVATE)
    class Onedrive implements ServiceConfig {
        /**
         * <p>bearer access token for OneDrive</p>
         */
        private final String accessToken;
        /**
         * <p>root path of OneDrive folder.</p>
         */
        private final String root;

        @Override
        public String scheme() {
            return "onedrive";
        }

        @Override
        public Map<String, String> configMap() {
            final HashMap<String, String> map = new HashMap<>();
            if (accessToken != null) {
                map.put("access_token", accessToken);
            }
            if (root != null) {
                map.put("root", root);
            }
            return map;
        }
    }

    /**
     * Configuration for service oss.
     */
    @Builder
    @Data
    @RequiredArgsConstructor(access = AccessLevel.PRIVATE)
    class Oss implements ServiceConfig {
        /**
         * <p>Bucket for oss.</p>
         */
        private final @NonNull String bucket;
        /**
         * <p>Root for oss.</p>
         */
        private final String root;
        /**
         * <p>Endpoint for oss.</p>
         */
        private final String endpoint;
        /**
         * <p>Presign endpoint for oss.</p>
         */
        private final String presignEndpoint;
        /**
         * <p>Server side encryption for oss.</p>
         */
        private final String serverSideEncryption;
        /**
         * <p>Server side encryption key id for oss.</p>
         */
        private final String serverSideEncryptionKeyId;
        /**
         * <p>Allow anonymous for oss.</p>
         */
        private final Boolean allowAnonymous;
        /**
         * <p>Access key id for oss.</p>
         */
        private final String accessKeyId;
        /**
         * <p>Access key secret for oss.</p>
         */
        private final String accessKeySecret;
        /**
         * <p>The size of max batch operations.</p>
         *
         * @deprecated Please use `delete_max_size` instead of `batch_max_operations`
         */
        private final Long batchMaxOperations;
        /**
         * <p>The size of max delete operations.</p>
         */
        private final Long deleteMaxSize;
        /**
         * <p>If <code>role_arn</code> is set, we will use already known config as source
         * credential to assume role with <code>role_arn</code>.</p>
         */
        private final String roleArn;
        /**
         * <p>role_session_name for this backend.</p>
         */
        private final String roleSessionName;
        /**
         * <p><code>oidc_provider_arn</code> will be loaded from</p>
         * <ul>
         * <li>this field if it's <code>is_some</code></li>
         * <li>env value: [<code>ALIBABA_CLOUD_OIDC_PROVIDER_ARN</code>]</li>
         * </ul>
         */
        private final String oidcProviderArn;
        /**
         * <p><code>oidc_token_file</code> will be loaded from</p>
         * <ul>
         * <li>this field if it's <code>is_some</code></li>
         * <li>env value: [<code>ALIBABA_CLOUD_OIDC_TOKEN_FILE</code>]</li>
         * </ul>
         */
        private final String oidcTokenFile;
        /**
         * <p><code>sts_endpoint</code> will be loaded from</p>
         * <ul>
         * <li>this field if it's <code>is_some</code></li>
         * <li>env value: [<code>ALIBABA_CLOUD_STS_ENDPOINT</code>]</li>
         * </ul>
         */
        private final String stsEndpoint;

        @Override
        public String scheme() {
            return "oss";
        }

        @Override
        public Map<String, String> configMap() {
            final HashMap<String, String> map = new HashMap<>();
            map.put("bucket", bucket);
            if (root != null) {
                map.put("root", root);
            }
            if (endpoint != null) {
                map.put("endpoint", endpoint);
            }
            if (presignEndpoint != null) {
                map.put("presign_endpoint", presignEndpoint);
            }
            if (serverSideEncryption != null) {
                map.put("server_side_encryption", serverSideEncryption);
            }
            if (serverSideEncryptionKeyId != null) {
                map.put("server_side_encryption_key_id", serverSideEncryptionKeyId);
            }
            if (allowAnonymous != null) {
                map.put("allow_anonymous", String.valueOf(allowAnonymous));
            }
            if (accessKeyId != null) {
                map.put("access_key_id", accessKeyId);
            }
            if (accessKeySecret != null) {
                map.put("access_key_secret", accessKeySecret);
            }
            if (batchMaxOperations != null) {
                map.put("batch_max_operations", String.valueOf(batchMaxOperations));
            }
            if (deleteMaxSize != null) {
                map.put("delete_max_size", String.valueOf(deleteMaxSize));
            }
            if (roleArn != null) {
                map.put("role_arn", roleArn);
            }
            if (roleSessionName != null) {
                map.put("role_session_name", roleSessionName);
            }
            if (oidcProviderArn != null) {
                map.put("oidc_provider_arn", oidcProviderArn);
            }
            if (oidcTokenFile != null) {
                map.put("oidc_token_file", oidcTokenFile);
            }
            if (stsEndpoint != null) {
                map.put("sts_endpoint", stsEndpoint);
            }
            return map;
        }
    }

    /**
     * Configuration for service pcloud.
     */
    @Builder
    @Data
    @RequiredArgsConstructor(access = AccessLevel.PRIVATE)
    class Pcloud implements ServiceConfig {
        /**
         * <p>pCloud  endpoint address.</p>
         */
        private final @NonNull String endpoint;
        /**
         * <p>root of this backend.</p>
         * <p>All operations will happen under this root.</p>
         */
        private final String root;
        /**
         * <p>pCloud username.</p>
         */
        private final String username;
        /**
         * <p>pCloud password.</p>
         */
        private final String password;

        @Override
        public String scheme() {
            return "pcloud";
        }

        @Override
        public Map<String, String> configMap() {
            final HashMap<String, String> map = new HashMap<>();
            map.put("endpoint", endpoint);
            if (root != null) {
                map.put("root", root);
            }
            if (username != null) {
                map.put("username", username);
            }
            if (password != null) {
                map.put("password", password);
            }
            return map;
        }
    }

    /**
     * Configuration for service persy.
     */
    @Builder
    @Data
    @RequiredArgsConstructor(access = AccessLevel.PRIVATE)
    class Persy implements ServiceConfig {
        /**
         * <p>That path to the persy data file. The directory in the path must already exist.</p>
         */
        private final String datafile;
        /**
         * <p>That name of the persy segment.</p>
         */
        private final String segment;
        /**
         * <p>That name of the persy index.</p>
         */
        private final String index;

        @Override
        public String scheme() {
            return "persy";
        }

        @Override
        public Map<String, String> configMap() {
            final HashMap<String, String> map = new HashMap<>();
            if (datafile != null) {
                map.put("datafile", datafile);
            }
            if (segment != null) {
                map.put("segment", segment);
            }
            if (index != null) {
                map.put("index", index);
            }
            return map;
        }
    }

    /**
     * Configuration for service postgresql.
     */
    @Builder
    @Data
    @RequiredArgsConstructor(access = AccessLevel.PRIVATE)
    class Postgresql implements ServiceConfig {
        /**
         * <p>Root of this backend.</p>
         * <p>All operations will happen under this root.</p>
         * <p>Default to <code>/</code> if not set.</p>
         */
        private final String root;
        /**
         * <p>The URL should be with a scheme of either <code>postgres://</code> or <code>postgresql://</code>.</p>
         * <ul>
         * <li><code>postgresql://user@localhost</code></li>
         * <li><code>postgresql://user:password@%2Fvar%2Flib%2Fpostgresql/mydb?connect_timeout=10</code></li>
         * <li><code>postgresql://user@host1:1234,host2,host3:5678?target_session_attrs=read-write</code></li>
         * <li><code>postgresql:///mydb?user=user&amp;host=/var/lib/postgresql</code></li>
         * </ul>
         * <p>For more information, please visit <a href="https://docs.rs/sqlx/latest/sqlx/postgres/struct.PgConnectOptions.html">https://docs.rs/sqlx/latest/sqlx/postgres/struct.PgConnectOptions.html</a>.</p>
         */
        private final String connectionString;
        /**
         * <p>the table of postgresql</p>
         */
        private final String table;
        /**
         * <p>the key field of postgresql</p>
         */
        private final String keyField;
        /**
         * <p>the value field of postgresql</p>
         */
        private final String valueField;

        @Override
        public String scheme() {
            return "postgresql";
        }

        @Override
        public Map<String, String> configMap() {
            final HashMap<String, String> map = new HashMap<>();
            if (root != null) {
                map.put("root", root);
            }
            if (connectionString != null) {
                map.put("connection_string", connectionString);
            }
            if (table != null) {
                map.put("table", table);
            }
            if (keyField != null) {
                map.put("key_field", keyField);
            }
            if (valueField != null) {
                map.put("value_field", valueField);
            }
            return map;
        }
    }

    /**
     * Configuration for service redb.
     */
    @Builder
    @Data
    @RequiredArgsConstructor(access = AccessLevel.PRIVATE)
    class Redb implements ServiceConfig {
        /**
         * <p>path to the redb data directory.</p>
         */
        private final String datadir;
        /**
         * <p>The root for redb.</p>
         */
        private final String root;
        /**
         * <p>The table name for redb.</p>
         */
        private final String table;

        @Override
        public String scheme() {
            return "redb";
        }

        @Override
        public Map<String, String> configMap() {
            final HashMap<String, String> map = new HashMap<>();
            if (datadir != null) {
                map.put("datadir", datadir);
            }
            if (root != null) {
                map.put("root", root);
            }
            if (table != null) {
                map.put("table", table);
            }
            return map;
        }
    }

    /**
     * Configuration for service redis.
     */
    @Builder
    @Data
    @RequiredArgsConstructor(access = AccessLevel.PRIVATE)
    class Redis implements ServiceConfig {
        /**
         * <p>the number of DBs redis can take is unlimited</p>
         * <p>default is db 0</p>
         */
        private final long db;
        /**
         * <p>network address of the Redis service. Can be &quot;tcp://127.0.0.1:6379&quot;, e.g.</p>
         * <p>default is &quot;tcp://127.0.0.1:6379&quot;</p>
         */
        private final String endpoint;
        /**
         * <p>network address of the Redis cluster service. Can be &quot;tcp://127.0.0.1:6379,tcp://127.0.0.1:6380,tcp://127.0.0.1:6381&quot;, e.g.</p>
         * <p>default is None</p>
         */
        private final String clusterEndpoints;
        /**
         * <p>the username to connect redis service.</p>
         * <p>default is None</p>
         */
        private final String username;
        /**
         * <p>the password for authentication</p>
         * <p>default is None</p>
         */
        private final String password;
        /**
         * <p>the working directory of the Redis service. Can be &quot;/path/to/dir&quot;</p>
         * <p>default is &quot;/&quot;</p>
         */
        private final String root;
        /**
         * <p>The default ttl for put operations.</p>
         */
        private final Duration defaultTtl;

        @Override
        public String scheme() {
            return "redis";
        }

        @Override
        public Map<String, String> configMap() {
            final HashMap<String, String> map = new HashMap<>();
            map.put("db", String.valueOf(db));
            if (endpoint != null) {
                map.put("endpoint", endpoint);
            }
            if (clusterEndpoints != null) {
                map.put("cluster_endpoints", clusterEndpoints);
            }
            if (username != null) {
                map.put("username", username);
            }
            if (password != null) {
                map.put("password", password);
            }
            if (root != null) {
                map.put("root", root);
            }
            if (defaultTtl != null) {
                map.put("default_ttl", defaultTtl.toString());
            }
            return map;
        }
    }

    /**
     * Configuration for service s3.
     */
    @Builder
    @Data
    @RequiredArgsConstructor(access = AccessLevel.PRIVATE)
    class S3 implements ServiceConfig {
        /**
         * <p>bucket name of this backend.</p>
         * <p>required.</p>
         */
        private final @NonNull String bucket;
        /**
         * <p>root of this backend.</p>
         * <p>All operations will happen under this root.</p>
         * <p>default to <code>/</code> if not set.</p>
         */
        private final String root;
        /**
         * <p>is bucket versioning enabled for this bucket</p>
         */
        private final Boolean enableVersioning;
        /**
         * <p>endpoint of this backend.</p>
         * <p>Endpoint must be full uri, e.g.</p>
         * <ul>
         * <li>AWS S3: <code>https://s3.amazonaws.com</code> or <code>https://s3.{region}.amazonaws.com</code></li>
         * <li>Cloudflare R2: <code>https://&lt;ACCOUNT_ID&gt;.r2.cloudflarestorage.com</code></li>
         * <li>Aliyun OSS: <code>https://{region}.aliyuncs.com</code></li>
         * <li>Tencent COS: <code>https://cos.{region}.myqcloud.com</code></li>
         * <li>Minio: <code>http://127.0.0.1:9000</code></li>
         * </ul>
         * <p>If user inputs endpoint without scheme like &quot;s3.amazonaws.com&quot;, we
         * will prepend &quot;https://&quot; before it.</p>
         * <ul>
         * <li>If endpoint is set, we will take user's input first.</li>
         * <li>If not, we will try to load it from environment.</li>
         * <li>If still not set, default to <code>https://s3.amazonaws.com</code>.</li>
         * </ul>
         */
        private final String endpoint;
        /**
         * <p>Region represent the signing region of this endpoint. This is required
         * if you are using the default AWS S3 endpoint.</p>
         * <p>If using a custom endpoint,</p>
         * <ul>
         * <li>If region is set, we will take user's input first.</li>
         * <li>If not, we will try to load it from environment.</li>
         * </ul>
         */
        private final String region;
        /**
         * <p>access_key_id of this backend.</p>
         * <ul>
         * <li>If access_key_id is set, we will take user's input first.</li>
         * <li>If not, we will try to load it from environment.</li>
         * </ul>
         */
        private final String accessKeyId;
        /**
         * <p>secret_access_key of this backend.</p>
         * <ul>
         * <li>If secret_access_key is set, we will take user's input first.</li>
         * <li>If not, we will try to load it from environment.</li>
         * </ul>
         */
        private final String secretAccessKey;
        /**
         * <p>session_token (aka, security token) of this backend.</p>
         * <p>This token will expire after sometime, it's recommended to set session_token
         * by hand.</p>
         */
        private final String sessionToken;
        /**
         * <p>role_arn for this backend.</p>
         * <p>If <code>role_arn</code> is set, we will use already known config as source
         * credential to assume role with <code>role_arn</code>.</p>
         */
        private final String roleArn;
        /**
         * <p>external_id for this backend.</p>
         */
        private final String externalId;
        /**
         * <p>role_session_name for this backend.</p>
         */
        private final String roleSessionName;
        /**
         * <p>Disable config load so that opendal will not load config from
         * environment.</p>
         * <p>For examples:</p>
         * <ul>
         * <li>envs like <code>AWS_ACCESS_KEY_ID</code></li>
         * <li>files like <code>~/.aws/config</code></li>
         * </ul>
         */
        private final Boolean disableConfigLoad;
        /**
         * <p>Disable load credential from ec2 metadata.</p>
         * <p>This option is used to disable the default behavior of opendal
         * to load credential from ec2 metadata, a.k.a, IMDSv2</p>
         */
        private final Boolean disableEc2Metadata;
        /**
         * <p>Allow anonymous will allow opendal to send request without signing
         * when credential is not loaded.</p>
         */
        private final Boolean allowAnonymous;
        /**
         * <p>server_side_encryption for this backend.</p>
         * <p>Available values: <code>AES256</code>, <code>aws:kms</code>.</p>
         */
        private final String serverSideEncryption;
        /**
         * <p>server_side_encryption_aws_kms_key_id for this backend</p>
         * <ul>
         * <li>If <code>server_side_encryption</code> set to <code>aws:kms</code>, and <code>server_side_encryption_aws_kms_key_id</code>
         * is not set, S3 will use aws managed kms key to encrypt data.</li>
         * <li>If <code>server_side_encryption</code> set to <code>aws:kms</code>, and <code>server_side_encryption_aws_kms_key_id</code>
         * is a valid kms key id, S3 will use the provided kms key to encrypt data.</li>
         * <li>If the <code>server_side_encryption_aws_kms_key_id</code> is invalid or not found, an error will be
         * returned.</li>
         * <li>If <code>server_side_encryption</code> is not <code>aws:kms</code>, setting <code>server_side_encryption_aws_kms_key_id</code>
         * is a noop.</li>
         * </ul>
         */
        private final String serverSideEncryptionAwsKmsKeyId;
        /**
         * <p>server_side_encryption_customer_algorithm for this backend.</p>
         * <p>Available values: <code>AES256</code>.</p>
         */
        private final String serverSideEncryptionCustomerAlgorithm;
        /**
         * <p>server_side_encryption_customer_key for this backend.</p>
         * <h1>Value</h1>
         * <p>base64 encoded key that matches algorithm specified in
         * <code>server_side_encryption_customer_algorithm</code>.</p>
         */
        private final String serverSideEncryptionCustomerKey;
        /**
         * <p>Set server_side_encryption_customer_key_md5 for this backend.</p>
         * <h1>Value</h1>
         * <p>MD5 digest of key specified in <code>server_side_encryption_customer_key</code>.</p>
         */
        private final String serverSideEncryptionCustomerKeyMd5;
        /**
         * <p>default storage_class for this backend.</p>
         * <p>Available values:</p>
         * <ul>
         * <li><code>DEEP_ARCHIVE</code></li>
         * <li><code>GLACIER</code></li>
         * <li><code>GLACIER_IR</code></li>
         * <li><code>INTELLIGENT_TIERING</code></li>
         * <li><code>ONEZONE_IA</code></li>
         * <li><code>OUTPOSTS</code></li>
         * <li><code>REDUCED_REDUNDANCY</code></li>
         * <li><code>STANDARD</code></li>
         * <li><code>STANDARD_IA</code></li>
         * </ul>
         * <p>S3 compatible services don't support all of them</p>
         */
        private final String defaultStorageClass;
        /**
         * <p>Enable virtual host style so that opendal will send API requests
         * in virtual host style instead of path style.</p>
         * <ul>
         * <li>By default, opendal will send API to <code>https://s3.us-east-1.amazonaws.com/bucket_name</code></li>
         * <li>Enabled, opendal will send API to <code>https://bucket_name.s3.us-east-1.amazonaws.com</code></li>
         * </ul>
         */
        private final Boolean enableVirtualHostStyle;
        /**
         * <p>Set maximum batch operations of this backend.</p>
         * <p>Some compatible services have a limit on the number of operations in a batch request.
         * For example, R2 could return <code>Internal Error</code> while batch delete 1000 files.</p>
         * <p>Please tune this value based on services' document.</p>
         *
         * @deprecated Please use `delete_max_size` instead of `batch_max_operations`
         */
        private final Long batchMaxOperations;
        /**
         * <p>Set the maximum delete size of this backend.</p>
         * <p>Some compatible services have a limit on the number of operations in a batch request.
         * For example, R2 could return <code>Internal Error</code> while batch delete 1000 files.</p>
         * <p>Please tune this value based on services' document.</p>
         */
        private final Long deleteMaxSize;
        /**
         * <p>Disable stat with override so that opendal will not send stat request with override queries.</p>
         * <p>For example, R2 doesn't support stat with <code>response_content_type</code> query.</p>
         */
        private final Boolean disableStatWithOverride;
        /**
         * <p>Checksum Algorithm to use when sending checksums in HTTP headers.
         * This is necessary when writing to AWS S3 Buckets with Object Lock enabled for example.</p>
         * <p>Available options:</p>
         * <ul>
         * <li>&quot;crc32c&quot;</li>
         * </ul>
         */
        private final String checksumAlgorithm;
        /**
         * <p>Disable write with if match so that opendal will not send write request with if match headers.</p>
         * <p>For example, Ceph RADOS S3 doesn't support write with if match.</p>
         */
        private final Boolean disableWriteWithIfMatch;

        @Override
        public String scheme() {
            return "s3";
        }

        @Override
        public Map<String, String> configMap() {
            final HashMap<String, String> map = new HashMap<>();
            map.put("bucket", bucket);
            if (root != null) {
                map.put("root", root);
            }
            if (enableVersioning != null) {
                map.put("enable_versioning", String.valueOf(enableVersioning));
            }
            if (endpoint != null) {
                map.put("endpoint", endpoint);
            }
            if (region != null) {
                map.put("region", region);
            }
            if (accessKeyId != null) {
                map.put("access_key_id", accessKeyId);
            }
            if (secretAccessKey != null) {
                map.put("secret_access_key", secretAccessKey);
            }
            if (sessionToken != null) {
                map.put("session_token", sessionToken);
            }
            if (roleArn != null) {
                map.put("role_arn", roleArn);
            }
            if (externalId != null) {
                map.put("external_id", externalId);
            }
            if (roleSessionName != null) {
                map.put("role_session_name", roleSessionName);
            }
            if (disableConfigLoad != null) {
                map.put("disable_config_load", String.valueOf(disableConfigLoad));
            }
            if (disableEc2Metadata != null) {
                map.put("disable_ec2_metadata", String.valueOf(disableEc2Metadata));
            }
            if (allowAnonymous != null) {
                map.put("allow_anonymous", String.valueOf(allowAnonymous));
            }
            if (serverSideEncryption != null) {
                map.put("server_side_encryption", serverSideEncryption);
            }
            if (serverSideEncryptionAwsKmsKeyId != null) {
                map.put("server_side_encryption_aws_kms_key_id", serverSideEncryptionAwsKmsKeyId);
            }
            if (serverSideEncryptionCustomerAlgorithm != null) {
                map.put("server_side_encryption_customer_algorithm", serverSideEncryptionCustomerAlgorithm);
            }
            if (serverSideEncryptionCustomerKey != null) {
                map.put("server_side_encryption_customer_key", serverSideEncryptionCustomerKey);
            }
            if (serverSideEncryptionCustomerKeyMd5 != null) {
                map.put("server_side_encryption_customer_key_md5", serverSideEncryptionCustomerKeyMd5);
            }
            if (defaultStorageClass != null) {
                map.put("default_storage_class", defaultStorageClass);
            }
            if (enableVirtualHostStyle != null) {
                map.put("enable_virtual_host_style", String.valueOf(enableVirtualHostStyle));
            }
            if (batchMaxOperations != null) {
                map.put("batch_max_operations", String.valueOf(batchMaxOperations));
            }
            if (deleteMaxSize != null) {
                map.put("delete_max_size", String.valueOf(deleteMaxSize));
            }
            if (disableStatWithOverride != null) {
                map.put("disable_stat_with_override", String.valueOf(disableStatWithOverride));
            }
            if (checksumAlgorithm != null) {
                map.put("checksum_algorithm", checksumAlgorithm);
            }
            if (disableWriteWithIfMatch != null) {
                map.put("disable_write_with_if_match", String.valueOf(disableWriteWithIfMatch));
            }
            return map;
        }
    }

    /**
     * Configuration for service seafile.
     */
    @Builder
    @Data
    @RequiredArgsConstructor(access = AccessLevel.PRIVATE)
    class Seafile implements ServiceConfig {
        /**
         * <p>repo_name of this backend.</p>
         * <p>required.</p>
         */
        private final @NonNull String repoName;
        /**
         * <p>root of this backend.</p>
         * <p>All operations will happen under this root.</p>
         */
        private final String root;
        /**
         * <p>endpoint address of this backend.</p>
         */
        private final String endpoint;
        /**
         * <p>username of this backend.</p>
         */
        private final String username;
        /**
         * <p>password of this backend.</p>
         */
        private final String password;

        @Override
        public String scheme() {
            return "seafile";
        }

        @Override
        public Map<String, String> configMap() {
            final HashMap<String, String> map = new HashMap<>();
            map.put("repo_name", repoName);
            if (root != null) {
                map.put("root", root);
            }
            if (endpoint != null) {
                map.put("endpoint", endpoint);
            }
            if (username != null) {
                map.put("username", username);
            }
            if (password != null) {
                map.put("password", password);
            }
            return map;
        }
    }

    /**
     * Configuration for service sftp.
     */
    @Builder
    @Data
    @RequiredArgsConstructor(access = AccessLevel.PRIVATE)
    class Sftp implements ServiceConfig {
        /**
         * <p>endpoint of this backend</p>
         */
        private final String endpoint;
        /**
         * <p>root of this backend</p>
         */
        private final String root;
        /**
         * <p>user of this backend</p>
         */
        private final String user;
        /**
         * <p>key of this backend</p>
         */
        private final String key;
        /**
         * <p>known_hosts_strategy of this backend</p>
         */
        private final String knownHostsStrategy;
        /**
         * <p>enable_copy of this backend</p>
         */
        private final Boolean enableCopy;

        @Override
        public String scheme() {
            return "sftp";
        }

        @Override
        public Map<String, String> configMap() {
            final HashMap<String, String> map = new HashMap<>();
            if (endpoint != null) {
                map.put("endpoint", endpoint);
            }
            if (root != null) {
                map.put("root", root);
            }
            if (user != null) {
                map.put("user", user);
            }
            if (key != null) {
                map.put("key", key);
            }
            if (knownHostsStrategy != null) {
                map.put("known_hosts_strategy", knownHostsStrategy);
            }
            if (enableCopy != null) {
                map.put("enable_copy", String.valueOf(enableCopy));
            }
            return map;
        }
    }

    /**
     * Configuration for service sled.
     */
    @Builder
    @Data
    @RequiredArgsConstructor(access = AccessLevel.PRIVATE)
    class Sled implements ServiceConfig {
        /**
         * <p>That path to the sled data directory.</p>
         */
        private final String datadir;
        /**
         * <p>The root for sled.</p>
         */
        private final String root;
        /**
         * <p>The tree for sled.</p>
         */
        private final String tree;

        @Override
        public String scheme() {
            return "sled";
        }

        @Override
        public Map<String, String> configMap() {
            final HashMap<String, String> map = new HashMap<>();
            if (datadir != null) {
                map.put("datadir", datadir);
            }
            if (root != null) {
                map.put("root", root);
            }
            if (tree != null) {
                map.put("tree", tree);
            }
            return map;
        }
    }

    /**
     * Configuration for service sqlite.
     */
    @Builder
    @Data
    @RequiredArgsConstructor(access = AccessLevel.PRIVATE)
    class Sqlite implements ServiceConfig {
        /**
         * <p>Set the connection_string of the sqlite service.</p>
         * <p>This connection string is used to connect to the sqlite service. There are url based formats:</p>
         * <h2>Url</h2>
         * <p>This format resembles the url format of the sqlite client:</p>
         * <ul>
         * <li><code>sqlite::memory:</code></li>
         * <li><code>sqlite:data.db</code></li>
         * <li><code>sqlite://data.db</code></li>
         * </ul>
         * <p>For more information, please visit <a href="https://docs.rs/sqlx/latest/sqlx/sqlite/struct.SqliteConnectOptions.html">https://docs.rs/sqlx/latest/sqlx/sqlite/struct.SqliteConnectOptions.html</a>.</p>
         */
        private final String connectionString;
        /**
         * <p>Set the table name of the sqlite service to read/write.</p>
         */
        private final String table;
        /**
         * <p>Set the key field name of the sqlite service to read/write.</p>
         * <p>Default to <code>key</code> if not specified.</p>
         */
        private final String keyField;
        /**
         * <p>Set the value field name of the sqlite service to read/write.</p>
         * <p>Default to <code>value</code> if not specified.</p>
         */
        private final String valueField;
        /**
         * <p>set the working directory, all operations will be performed under it.</p>
         * <p>default: &quot;/&quot;</p>
         */
        private final String root;

        @Override
        public String scheme() {
            return "sqlite";
        }

        @Override
        public Map<String, String> configMap() {
            final HashMap<String, String> map = new HashMap<>();
            if (connectionString != null) {
                map.put("connection_string", connectionString);
            }
            if (table != null) {
                map.put("table", table);
            }
            if (keyField != null) {
                map.put("key_field", keyField);
            }
            if (valueField != null) {
                map.put("value_field", valueField);
            }
            if (root != null) {
                map.put("root", root);
            }
            return map;
        }
    }

    /**
     * Configuration for service supabase.
     */
    @Builder
    @Data
    @RequiredArgsConstructor(access = AccessLevel.PRIVATE)
    class Supabase implements ServiceConfig {
        /**
         * <p>The bucket for supabase service.</p>
         */
        private final @NonNull String bucket;
        /**
         * <p>The root for supabase service.</p>
         */
        private final String root;
        /**
         * <p>The endpoint for supabase service.</p>
         */
        private final String endpoint;
        /**
         * <p>The key for supabase service.</p>
         */
        private final String key;

        @Override
        public String scheme() {
            return "supabase";
        }

        @Override
        public Map<String, String> configMap() {
            final HashMap<String, String> map = new HashMap<>();
            map.put("bucket", bucket);
            if (root != null) {
                map.put("root", root);
            }
            if (endpoint != null) {
                map.put("endpoint", endpoint);
            }
            if (key != null) {
                map.put("key", key);
            }
            return map;
        }
    }

    /**
     * Configuration for service surrealdb.
     */
    @Builder
    @Data
    @RequiredArgsConstructor(access = AccessLevel.PRIVATE)
    class Surrealdb implements ServiceConfig {
        /**
         * <p>The connection string for surrealdb.</p>
         */
        private final String connectionString;
        /**
         * <p>The username for surrealdb.</p>
         */
        private final String username;
        /**
         * <p>The password for surrealdb.</p>
         */
        private final String password;
        /**
         * <p>The namespace for surrealdb.</p>
         */
        private final String namespace;
        /**
         * <p>The database for surrealdb.</p>
         */
        private final String database;
        /**
         * <p>The table for surrealdb.</p>
         */
        private final String table;
        /**
         * <p>The key field for surrealdb.</p>
         */
        private final String keyField;
        /**
         * <p>The value field for surrealdb.</p>
         */
        private final String valueField;
        /**
         * <p>The root for surrealdb.</p>
         */
        private final String root;

        @Override
        public String scheme() {
            return "surrealdb";
        }

        @Override
        public Map<String, String> configMap() {
            final HashMap<String, String> map = new HashMap<>();
            if (connectionString != null) {
                map.put("connection_string", connectionString);
            }
            if (username != null) {
                map.put("username", username);
            }
            if (password != null) {
                map.put("password", password);
            }
            if (namespace != null) {
                map.put("namespace", namespace);
            }
            if (database != null) {
                map.put("database", database);
            }
            if (table != null) {
                map.put("table", table);
            }
            if (keyField != null) {
                map.put("key_field", keyField);
            }
            if (valueField != null) {
                map.put("value_field", valueField);
            }
            if (root != null) {
                map.put("root", root);
            }
            return map;
        }
    }

    /**
     * Configuration for service swift.
     */
    @Builder
    @Data
    @RequiredArgsConstructor(access = AccessLevel.PRIVATE)
    class Swift implements ServiceConfig {
        /**
         * <p>The endpoint for Swift.</p>
         */
        private final String endpoint;
        /**
         * <p>The container for Swift.</p>
         */
        private final String container;
        /**
         * <p>The root for Swift.</p>
         */
        private final String root;
        /**
         * <p>The token for Swift.</p>
         */
        private final String token;

        @Override
        public String scheme() {
            return "swift";
        }

        @Override
        public Map<String, String> configMap() {
            final HashMap<String, String> map = new HashMap<>();
            if (endpoint != null) {
                map.put("endpoint", endpoint);
            }
            if (container != null) {
                map.put("container", container);
            }
            if (root != null) {
                map.put("root", root);
            }
            if (token != null) {
                map.put("token", token);
            }
            return map;
        }
    }

    /**
     * Configuration for service upyun.
     */
    @Builder
    @Data
    @RequiredArgsConstructor(access = AccessLevel.PRIVATE)
    class Upyun implements ServiceConfig {
        /**
         * <p>bucket address of this backend.</p>
         */
        private final @NonNull String bucket;
        /**
         * <p>root of this backend.</p>
         * <p>All operations will happen under this root.</p>
         */
        private final String root;
        /**
         * <p>username of this backend.</p>
         */
        private final String operator;
        /**
         * <p>password of this backend.</p>
         */
        private final String password;

        @Override
        public String scheme() {
            return "upyun";
        }

        @Override
        public Map<String, String> configMap() {
            final HashMap<String, String> map = new HashMap<>();
            map.put("bucket", bucket);
            if (root != null) {
                map.put("root", root);
            }
            if (operator != null) {
                map.put("operator", operator);
            }
            if (password != null) {
                map.put("password", password);
            }
            return map;
        }
    }

    /**
     * Configuration for service vercel_artifacts.
     */
    @Builder
    @Data
    @RequiredArgsConstructor(access = AccessLevel.PRIVATE)
    class VercelArtifacts implements ServiceConfig {
        /**
         * <p>The access token for Vercel.</p>
         */
        private final String accessToken;

        @Override
        public String scheme() {
            return "vercel_artifacts";
        }

        @Override
        public Map<String, String> configMap() {
            final HashMap<String, String> map = new HashMap<>();
            if (accessToken != null) {
                map.put("access_token", accessToken);
            }
            return map;
        }
    }

    /**
     * Configuration for service vercel_blob.
     */
    @Builder
    @Data
    @RequiredArgsConstructor(access = AccessLevel.PRIVATE)
    class VercelBlob implements ServiceConfig {
        /**
         * <p>root of this backend.</p>
         * <p>All operations will happen under this root.</p>
         */
        private final String root;
        /**
         * <p>vercel blob token.</p>
         */
        private final String token;

        @Override
        public String scheme() {
            return "vercel_blob";
        }

        @Override
        public Map<String, String> configMap() {
            final HashMap<String, String> map = new HashMap<>();
            if (root != null) {
                map.put("root", root);
            }
            if (token != null) {
                map.put("token", token);
            }
            return map;
        }
    }

    /**
     * Configuration for service webdav.
     */
    @Builder
    @Data
    @RequiredArgsConstructor(access = AccessLevel.PRIVATE)
    class Webdav implements ServiceConfig {
        /**
         * <p>endpoint of this backend</p>
         */
        private final String endpoint;
        /**
         * <p>username of this backend</p>
         */
        private final String username;
        /**
         * <p>password of this backend</p>
         */
        private final String password;
        /**
         * <p>token of this backend</p>
         */
        private final String token;
        /**
         * <p>root of this backend</p>
         */
        private final String root;
        /**
         * <p>WebDAV Service doesn't support copy.</p>
         */
        private final Boolean disableCopy;

        @Override
        public String scheme() {
            return "webdav";
        }

        @Override
        public Map<String, String> configMap() {
            final HashMap<String, String> map = new HashMap<>();
            if (endpoint != null) {
                map.put("endpoint", endpoint);
            }
            if (username != null) {
                map.put("username", username);
            }
            if (password != null) {
                map.put("password", password);
            }
            if (token != null) {
                map.put("token", token);
            }
            if (root != null) {
                map.put("root", root);
            }
            if (disableCopy != null) {
                map.put("disable_copy", String.valueOf(disableCopy));
            }
            return map;
        }
    }

    /**
     * Configuration for service webhdfs.
     */
    @Builder
    @Data
    @RequiredArgsConstructor(access = AccessLevel.PRIVATE)
    class Webhdfs implements ServiceConfig {
        /**
         * <p>Root for webhdfs.</p>
         */
        private final String root;
        /**
         * <p>Endpoint for webhdfs.</p>
         */
        private final String endpoint;
        /**
         * <p>Delegation token for webhdfs.</p>
         */
        private final String delegation;
        /**
         * <p>Disable batch listing</p>
         */
        private final Boolean disableListBatch;
        /**
         * <p>atomic_write_dir of this backend</p>
         */
        private final String atomicWriteDir;

        @Override
        public String scheme() {
            return "webhdfs";
        }

        @Override
        public Map<String, String> configMap() {
            final HashMap<String, String> map = new HashMap<>();
            if (root != null) {
                map.put("root", root);
            }
            if (endpoint != null) {
                map.put("endpoint", endpoint);
            }
            if (delegation != null) {
                map.put("delegation", delegation);
            }
            if (disableListBatch != null) {
                map.put("disable_list_batch", String.valueOf(disableListBatch));
            }
            if (atomicWriteDir != null) {
                map.put("atomic_write_dir", atomicWriteDir);
            }
            return map;
        }
    }

    /**
     * Configuration for service yandex_disk.
     */
    @Builder
    @Data
    @RequiredArgsConstructor(access = AccessLevel.PRIVATE)
    class YandexDisk implements ServiceConfig {
        /**
         * <p>yandex disk oauth access_token.</p>
         */
        private final @NonNull String accessToken;
        /**
         * <p>root of this backend.</p>
         * <p>All operations will happen under this root.</p>
         */
        private final String root;

        @Override
        public String scheme() {
            return "yandex_disk";
        }

        @Override
        public Map<String, String> configMap() {
            final HashMap<String, String> map = new HashMap<>();
            map.put("access_token", accessToken);
            if (root != null) {
                map.put("root", root);
            }
            return map;
        }
    }
}
