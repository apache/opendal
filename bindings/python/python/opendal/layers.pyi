# This file is automatically generated by pyo3_stub_gen
# ruff: noqa: E501, F401

import builtins
import typing

from typing_extensions import Self

class ConcurrentLimitLayer(Layer):
    r"""
    ConcurrentLimitLayer.

    A layer that adds a concurrent request limit to control the number of
    concurrent connections could be established between OpenDAL and
    underlying storage services.

    Notes
    -----
        Users can control how many concurrent connections could be established
        between OpenDAL and underlying storage services.

        All operators wrapped by this layer will share a common semaphore. This
        allows you to reuse the same layer across multiple operators, ensuring
        that the total number of concurrent requests across the entire
        application does not exceed the limit.
    """

    def __new__(cls, limit: builtins.int) -> Self:
        r"""
        Create a new ConcurrentLimitLayer.

        # Arguments

        * `limit` - The maximum number of concurrent requests.
        """

class Layer:
    r"""Layer is used to intercept the operations on the underlying storage."""

class MimeGuessLayer(Layer):
    r"""
    MimeGuessLayer.

    A layer to automatically set `Content-Type` from a path's extension.

    This layer uses [`mime_guess`](https://crates.io/crates/mime_guess)
    to infer the `Content-Type`.

    Notes
    -----
        This layer will NOT override a `Content-Type` that has already
        been set, either manually or by the backend service. It is only
        applied if no content type is present.

        A `Content-Type` is not guaranteed. If the file extension is
        uncommon or unknown, the content type will remain unset.
    """

    def __new__(cls) -> Self:
        r"""Create a new MimeGuessLayer."""

class RetryLayer(Layer):
    r"""
    RetryLayer.

    A layer that retries operations that fail with temporary errors.

    Operations are retried if they fail with an error for which
    `Error.is_temporary` returns `True`. If all retries are exhausted,
    the error is marked as persistent and then returned.

    Notes
    -----
        After an operation on a `Reader` or `Writer` has failed through
        all retries, the object is in an undefined state. Reusing it
        can lead to a panic.
    """

    def __new__(
        cls,
        max_times: builtins.int | None = None,
        factor: builtins.float | None = None,
        jitter: builtins.bool = False,
        max_delay: builtins.float | None = None,
        min_delay: builtins.float | None = None,
    ) -> Self:
        r"""
        Create a new RetryLayer.

        # Arguments

        * `max_times` - The maximum number of retries.
        * `factor` - The exponential backoff factor.
        * `jitter` - Whether to add jitter to the backoff.
        * `max_delay` - The maximum delay between retries.
        * `min_delay` - The minimum delay between retries.
        """
