{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Apache OpenDAL\u2122 Python binding","text":""},{"location":"#installation","title":"Installation","text":"<pre><code>pip install opendal\n</code></pre>"},{"location":"#local-usage","title":"Local Usage","text":"<p>Developer must set two required arguments to work with files locally: - <code>scheme</code>: which should be specified as <code>fs</code> - <code>root</code>: where OpenDAl considers the root of the directory for operations will be.</p> <p>For example in the following operator: <code>opendal.Operator(\"fs\", root=\"/foo\")</code></p> <p>OpenDAL considers <code>/foo</code> to be the root of all paths, and that means that we can access paths inside of <code>/foo</code> without specifying anything else. If <code>/foo</code> happens to contain the file <code>baz.txt</code>, we can simply call <code>.list(\"/\")</code></p> <p>We can see this in the following example:</p> <pre><code>from opendal import Operator\nfrom pathlib import Path\nimport os\n\n\nos.makedirs(\"foo\", exist_ok=True)\n\nfile = Path(\"foo\", \"bar.txt\")\nfile.touch()\n\nop = Operator(\"fs\", root=Path(\"foo\").name)\nfor file in op.list(\"/\"):\n    print(file)\n</code></pre> <p>When running we get the following output:</p> <pre><code>/\nbar.txt\n</code></pre> <p>If we want full access to our file system, we can specify a root of <code>\"/\"</code>, but note that for any operations you will always need to specify the full path to a file or directory.</p>"},{"location":"#reading","title":"Reading","text":"<p>There are two ways to read data using OpenDAL. One way is to use the <code>read</code> method on an operator: <pre><code>from opendal import Operator\nfrom pathlib import Path\nimport os\n\n\nos.makedirs(\"foo\", exist_ok=True)\n\nfile = Path(\"foo\", \"bar.txt\")\nfile.touch()\nfile.write_text(\"baz\")\n\n\nop = Operator(\"fs\", root=Path(\"foo\").name)\n\ndata = op.read(file.name)\nprint(data)\n</code></pre></p> <p>Yields the following: <pre><code>b'baz'\n</code></pre></p> <p>Note that the output is bytes, but we can get it as a string by simply calling <code>.decode()</code> on the data we read. All reads with OpenDAL return bytes.</p> <p>Now lets use the <code>open</code> method on an operator: <pre><code>from opendal import Operator\nfrom pathlib import Path\nimport os\n\n\nos.makedirs(\"foo\", exist_ok=True)\n\nfile = Path(\"foo\", \"bar.txt\")\nfile.touch()\nfile.write_text(\"baz\")\n\n\nop = Operator(\"fs\", root=Path(\"foo\").name)\n\nwith op.open(file.name, \"rb\") as f:\n    print(f.read())\n</code></pre></p> <p>This again yields <pre><code>b'baz'\n</code></pre></p> <p>Again, note that all reads with OpenDAL return bytes, so specifying a mode of <code>\"r\"</code> will raise an exception.</p>"},{"location":"#writing","title":"Writing","text":"<p>Now that we know how to read data, let's replace the <code>Pathlib</code> code above with OpenDAL using the <code>write</code> method: <pre><code>from opendal import Operator\nfrom pathlib import Path\n\n\nop = Operator(\"fs\", root=Path(\"foo\").name)\n\nop.write(\"baz.txt\", \"my amazing data\".encode())\n\nprint(op.read(\"baz.txt\").decode())\n</code></pre></p> <p>This yields the following: <pre><code>my amazing data\n</code></pre></p> <p>And again, but using the <code>open</code> method: <pre><code>from opendal import Operator\nfrom pathlib import Path\n\n\nop = Operator(\"fs\", root=Path(\"foo\").name)\n\nwith op.open(\"baz.txt\", \"wb\") as f:\n    f.write(\"my amazing data\".encode())\n\nprint(op.read(\"baz.txt\").decode())\n</code></pre></p> <p>This again yields:</p> <pre><code>my amazing data\n</code></pre> <p>Again, note that all writing happens in bytes and a mode of <code>\"w\"</code> will raise an exception.</p>"},{"location":"#async","title":"Async","text":"<p>OpenDAL supports async operation on all operator methods. One can simply replace the <code>Operator</code> with an <code>AsyncOperator</code> and await on method calls. The below example illustrates this behavior:</p> <p>Standard API:</p> <pre><code>import opendal\n\nop = opendal.Operator(\"fs\", root=\"/tmp\")\nop.write(\"test.txt\", b\"Hello World\")\nprint(op.read(\"test.txt\"))\nprint(op.stat(\"test.txt\").content_length)\n</code></pre> <p>Async API equivalent:</p> <pre><code>import asyncio\n\nasync def main():\n    op = opendal.AsyncOperator(\"fs\", root=\"/tmp\")\n    await op.write(\"test.txt\", b\"Hello World\")\n    print(await op.read(\"test.txt\"))\n\nasyncio.run(main())\n</code></pre>"},{"location":"api/async_file/","title":"AsyncFile","text":"<p>An async file-like object for reading and writing data.</p> <p>Created by the <code>open</code> method of the <code>AsyncOperator</code> class.</p>"},{"location":"api/async_file/#opendal.file.AsyncFile.closed","title":"<code>closed</code>  <code>property</code>","text":"<p>Whether this file is closed.</p> <p>Returns:</p> Type Description <code>coroutine</code> <p>An awaitable that returns True if this file is closed.</p>"},{"location":"api/async_file/#opendal.file.AsyncFile.close","title":"<code>close()</code>","text":"<p>Close this file.</p> <p>This also flushes write buffers, if applicable.</p> Notes <p>A closed file cannot be used for further I/O operations.</p>"},{"location":"api/async_file/#opendal.file.AsyncFile.read","title":"<code>read(size=None)</code>","text":"<p>Read at most <code>size</code> bytes from this file asynchronously.</p> <p>If <code>size</code> is not specified, read until EOF.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>The maximum number of bytes to read.</p> <code>None</code> Notes <p>Fewer bytes may be returned than requested, read in a loop to ensure all bytes are read.</p> <p>Returns:</p> Type Description <code>coroutine</code> <p>An awaitable that returns the bytes read from the stream.</p>"},{"location":"api/async_file/#opendal.file.AsyncFile.readable","title":"<code>readable()</code>","text":"<p>Whether this file can be read from.</p> <p>Returns:</p> Type Description <code>coroutine</code> <p>An awaitable that returns True if this file can be read from.</p>"},{"location":"api/async_file/#opendal.file.AsyncFile.seek","title":"<code>seek(pos, whence=0)</code>","text":"<p>Change the position of this file to the given byte offset.</p> <p>Parameters:</p> Name Type Description Default <code>pos</code> <code>int</code> <p>The byte offset (position) to set.</p> required <code>whence</code> <code>int</code> <p>The reference point for the offset. 0: start of file (default); 1: current position; 2: end of file.</p> <code>0</code> <p>Returns:</p> Type Description <code>coroutine</code> <p>An awaitable that returns the current absolute position.</p>"},{"location":"api/async_file/#opendal.file.AsyncFile.seekable","title":"<code>seekable()</code>","text":"<p>Whether this file can be repositioned.</p> Notes <p>This is only applicable to readable files.</p> <p>Returns:</p> Type Description <code>coroutine</code> <p>An awaitable that returns True if this file can be repositioned.</p>"},{"location":"api/async_file/#opendal.file.AsyncFile.tell","title":"<code>tell()</code>","text":"<p>Return the current position of this file.</p> <p>Returns:</p> Type Description <code>coroutine</code> <p>An awaitable that returns the current absolute position.</p>"},{"location":"api/async_file/#opendal.file.AsyncFile.writable","title":"<code>writable()</code>","text":"<p>Whether this file can be written to.</p> <p>Returns:</p> Type Description <code>coroutine</code> <p>An awaitable that returns True if this file can be written to.</p>"},{"location":"api/async_file/#opendal.file.AsyncFile.write","title":"<code>write(bs)</code>","text":"<p>Write bytes to this file asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>bs</code> <code>bytes</code> <p>The bytes to write to the file.</p> required <p>Returns:</p> Type Description <code>coroutine</code> <p>An awaitable that returns the number of bytes written.</p>"},{"location":"api/async_operator/","title":"AsyncOperator","text":"<p>The async equivalent of <code>Operator</code>.</p> <p><code>AsyncOperator</code> is the entry point for all async APIs.</p> See Also <p>Operator</p>"},{"location":"api/async_operator/#opendal.AsyncOperator.capability","title":"<code>capability()</code>","text":"<p>Get all capabilities of this operator.</p> <p>Returns:</p> Type Description <code>Capability</code> <p>The capability of the operator.</p>"},{"location":"api/async_operator/#opendal.AsyncOperator.check","title":"<code>check()</code>","text":"<p>Check if the operator is able to work correctly.</p> <p>Returns:</p> Type Description <code>coroutine</code> <p>An awaitable that completes when the check is finished.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the operator is not able to work correctly.</p>"},{"location":"api/async_operator/#opendal.AsyncOperator.copy","title":"<code>copy(source, target)</code>","text":"<p>Copy a file from one path to another.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>The path to the source file.</p> required <code>target</code> <code>str</code> <p>The path to the target file.</p> required <p>Returns:</p> Type Description <code>coroutine</code> <p>An awaitable that completes when the copy is finished.</p>"},{"location":"api/async_operator/#opendal.AsyncOperator.create_dir","title":"<code>create_dir(path)</code>","text":"<p>Create a directory at the given path.</p> Notes <p>To indicate that a path is a directory, it must end with a <code>/</code>. This operation is always recursive, like <code>mkdir -p</code>.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to the directory.</p> required <p>Returns:</p> Type Description <code>coroutine</code> <p>An awaitable that completes when the directory is created.</p>"},{"location":"api/async_operator/#opendal.AsyncOperator.delete","title":"<code>delete(path)</code>","text":"<p>Delete a file at the given path.</p> Notes <p>This operation will not return an error if the path does not exist.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to the file.</p> required <p>Returns:</p> Type Description <code>coroutine</code> <p>An awaitable that completes when the file is deleted.</p>"},{"location":"api/async_operator/#opendal.AsyncOperator.exists","title":"<code>exists(path)</code>","text":"<p>Check if a path exists.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to check.</p> required <p>Returns:</p> Type Description <code>coroutine</code> <p>An awaitable that returns True if the path exists, False otherwise.</p>"},{"location":"api/async_operator/#opendal.AsyncOperator.layer","title":"<code>layer(layer)</code>","text":"<p>Add a new layer to the operator.</p> <p>Parameters:</p> Name Type Description Default <code>layer</code> <code>Layer</code> <p>The layer to add.</p> required <p>Returns:</p> Type Description <code>AsyncOperator</code> <p>A new operator with the layer added.</p>"},{"location":"api/async_operator/#opendal.AsyncOperator.list","title":"<code>list(path, *, limit=None, start_after=None, recursive=None, versions=None, deleted=None)</code>","text":"<p>List entries in the given directory.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to the directory.</p> required <code>limit</code> <code>int</code> <p>The maximum number of entries to return.</p> <code>None</code> <code>start_after</code> <code>str</code> <p>The entry to start after.</p> <code>None</code> <code>recursive</code> <code>bool</code> <p>Whether to list recursively.</p> <code>None</code> <code>versions</code> <code>bool</code> <p>Whether to list versions.</p> <code>None</code> <code>deleted</code> <code>bool</code> <p>Whether to list deleted entries.</p> <code>None</code> <p>Returns:</p> Type Description <code>coroutine</code> <p>An awaitable that returns an async iterator over the entries.</p>"},{"location":"api/async_operator/#opendal.AsyncOperator.open","title":"<code>open(path, mode, **kwargs)</code>","text":"<p>Open an async file-like object for the given path.</p> <p>The returning async file-like object is a context manager.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to the file.</p> required <code>mode</code> <code>str</code> <p>The mode to open the file in. Only \"rb\" and \"wb\" are supported.</p> required <code>**kwargs</code> <code>dict</code> <p>Additional options for the underlying reader or writer.</p> <code>{}</code> <p>Returns:</p> Type Description <code>coroutine</code> <p>An awaitable that returns a file-like object.</p>"},{"location":"api/async_operator/#opendal.AsyncOperator.presign_delete","title":"<code>presign_delete(path, expire_second)</code>","text":"<p>Create a presigned request for a delete operation.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path of the object to delete.</p> required <code>expire_second</code> <code>int</code> <p>The number of seconds until the presigned URL expires.</p> required <p>Returns:</p> Type Description <code>coroutine</code> <p>An awaitable that returns a presigned request object.</p>"},{"location":"api/async_operator/#opendal.AsyncOperator.presign_read","title":"<code>presign_read(path, expire_second)</code>","text":"<p>Create a presigned request for a read operation.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path of the object to read.</p> required <code>expire_second</code> <code>int</code> <p>The number of seconds until the presigned URL expires.</p> required <p>Returns:</p> Type Description <code>coroutine</code> <p>An awaitable that returns a presigned request object.</p>"},{"location":"api/async_operator/#opendal.AsyncOperator.presign_stat","title":"<code>presign_stat(path, expire_second)</code>","text":"<p>Create a presigned request for a stat operation.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path of the object to stat.</p> required <code>expire_second</code> <code>int</code> <p>The number of seconds until the presigned URL expires.</p> required <p>Returns:</p> Type Description <code>coroutine</code> <p>An awaitable that returns a presigned request object.</p>"},{"location":"api/async_operator/#opendal.AsyncOperator.presign_write","title":"<code>presign_write(path, expire_second)</code>","text":"<p>Create a presigned request for a write operation.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path of the object to write to.</p> required <code>expire_second</code> <code>int</code> <p>The number of seconds until the presigned URL expires.</p> required <p>Returns:</p> Type Description <code>coroutine</code> <p>An awaitable that returns a presigned request object.</p>"},{"location":"api/async_operator/#opendal.AsyncOperator.read","title":"<code>read(path, *, version=None, concurrent=None, chunk=None, gap=None, offset=None, prefetch=None, size=None, if_match=None, if_none_match=None, if_modified_since=None, if_unmodified_since=None, content_type=None, cache_control=None, content_disposition=None)</code>","text":"<p>Read the entire contents of a file at the given path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to the file.</p> required <code>version</code> <code>str</code> <p>The version of the file.</p> <code>None</code> <code>concurrent</code> <code>int</code> <p>The number of concurrent readers.</p> <code>None</code> <code>chunk</code> <code>int</code> <p>The size of each chunk.</p> <code>None</code> <code>gap</code> <code>int</code> <p>The gap between each chunk.</p> <code>None</code> <code>offset</code> <code>int</code> <p>The offset of the file.</p> <code>None</code> <code>prefetch</code> <code>int</code> <p>The number of bytes to prefetch.</p> <code>None</code> <code>size</code> <code>int</code> <p>The size of the file.</p> <code>None</code> <code>if_match</code> <code>str</code> <p>The ETag of the file.</p> <code>None</code> <code>if_none_match</code> <code>str</code> <p>The ETag of the file.</p> <code>None</code> <code>if_modified_since</code> <code>str</code> <p>The last modified time of the file.</p> <code>None</code> <code>if_unmodified_since</code> <code>str</code> <p>The last modified time of the file.</p> <code>None</code> <code>content_type</code> <code>str</code> <p>The content type of the file.</p> <code>None</code> <code>cache_control</code> <code>str</code> <p>The cache control of the file.</p> <code>None</code> <code>content_disposition</code> <code>str</code> <p>The content disposition of the file.</p> <code>None</code> <p>Returns:</p> Type Description <code>coroutine</code> <p>An awaitable that returns the contents of the file as bytes.</p>"},{"location":"api/async_operator/#opendal.AsyncOperator.remove_all","title":"<code>remove_all(path)</code>","text":"<p>Recursively remove all files and directories at the given path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to remove.</p> required <p>Returns:</p> Type Description <code>coroutine</code> <p>An awaitable that completes when the removal is finished.</p>"},{"location":"api/async_operator/#opendal.AsyncOperator.rename","title":"<code>rename(source, target)</code>","text":"<p>Rename (move) a file from one path to another.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>The path to the source file.</p> required <code>target</code> <code>str</code> <p>The path to the target file.</p> required <p>Returns:</p> Type Description <code>coroutine</code> <p>An awaitable that completes when the rename is finished.</p>"},{"location":"api/async_operator/#opendal.AsyncOperator.stat","title":"<code>stat(path, *, version=None, if_match=None, if_none_match=None, if_modified_since=None, if_unmodified_since=None, content_type=None, cache_control=None, content_disposition=None)</code>","text":"<p>Get the metadata of a file at the given path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to the file.</p> required <code>version</code> <code>str</code> <p>The version of the file.</p> <code>None</code> <code>if_match</code> <code>str</code> <p>The ETag of the file.</p> <code>None</code> <code>if_none_match</code> <code>str</code> <p>The ETag of the file.</p> <code>None</code> <code>if_modified_since</code> <code>datetime</code> <p>The last modified time of the file.</p> <code>None</code> <code>if_unmodified_since</code> <code>datetime</code> <p>The last modified time of the file.</p> <code>None</code> <code>content_type</code> <code>str</code> <p>The content type of the file.</p> <code>None</code> <code>cache_control</code> <code>str</code> <p>The cache control of the file.</p> <code>None</code> <code>content_disposition</code> <code>str</code> <p>The content disposition of the file.</p> <code>None</code> <p>Returns:</p> Type Description <code>coroutine</code> <p>An awaitable that returns the metadata of the file.</p>"},{"location":"api/async_operator/#opendal.AsyncOperator.to_operator","title":"<code>to_operator()</code>","text":"<p>Create a new blocking <code>Operator</code> from this async operator.</p> <p>Returns:</p> Type Description <code>Operator</code> <p>The blocking operator.</p>"},{"location":"api/async_operator/#opendal.AsyncOperator.write","title":"<code>write(path, bs, *, append=None, chunk=None, concurrent=None, cache_control=None, content_type=None, content_disposition=None, content_encoding=None, if_match=None, if_none_match=None, if_not_exists=None, user_metadata=None)</code>","text":"<p>Write bytes to a file at the given path.</p> <p>This function will create a file if it does not exist, and will overwrite its contents if it does.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to the file.</p> required <code>bs</code> <code>bytes</code> <p>The contents to write to the file.</p> required <code>append</code> <code>bool</code> <p>Whether to append to the file instead of overwriting it.</p> <code>None</code> <code>chunk</code> <code>int</code> <p>The chunk size to use when writing the file.</p> <code>None</code> <code>concurrent</code> <code>int</code> <p>The number of concurrent requests to make when writing the file.</p> <code>None</code> <code>cache_control</code> <code>str</code> <p>The cache control header to set on the file.</p> <code>None</code> <code>content_type</code> <code>str</code> <p>The content type header to set on the file.</p> <code>None</code> <code>content_disposition</code> <code>str</code> <p>The content disposition header to set on the file.</p> <code>None</code> <code>content_encoding</code> <code>str</code> <p>The content encoding header to set on the file.</p> <code>None</code> <code>if_match</code> <code>str</code> <p>The ETag to match when writing the file.</p> <code>None</code> <code>if_none_match</code> <code>str</code> <p>The ETag to not match when writing the file.</p> <code>None</code> <code>if_not_exists</code> <code>bool</code> <p>Whether to fail if the file already exists.</p> <code>None</code> <code>user_metadata</code> <code>dict</code> <p>The user metadata to set on the file.</p> <code>None</code> <p>Returns:</p> Type Description <code>coroutine</code> <p>An awaitable that completes when the write is finished.</p>"},{"location":"api/capability/","title":"Capability","text":"<p>Capability defines the supported operations and their constraints for an Operator.</p> <p>This structure provides a comprehensive description of an Operator's capabilities, including:</p> <ul> <li>Basic operations support (read, write, delete, etc.)</li> <li>Advanced operation variants (conditional operations, metadata handling)</li> <li>Operational constraints (size limits, batch limitations)</li> </ul>"},{"location":"api/capability/#opendal.capability.Capability.copy","title":"<code>copy</code>  <code>property</code>","text":"<p>If operator supports copy.</p>"},{"location":"api/capability/#opendal.capability.Capability.create_dir","title":"<code>create_dir</code>  <code>property</code>","text":"<p>If operator supports create dir.</p>"},{"location":"api/capability/#opendal.capability.Capability.delete","title":"<code>delete</code>  <code>property</code>","text":"<p>If operator supports delete.</p>"},{"location":"api/capability/#opendal.capability.Capability.list","title":"<code>list</code>  <code>property</code>","text":"<p>If operator supports list.</p>"},{"location":"api/capability/#opendal.capability.Capability.list_with_limit","title":"<code>list_with_limit</code>  <code>property</code>","text":"<p>If backend supports list with limit.</p>"},{"location":"api/capability/#opendal.capability.Capability.list_with_recursive","title":"<code>list_with_recursive</code>  <code>property</code>","text":"<p>If backend supports list without delimiter.</p>"},{"location":"api/capability/#opendal.capability.Capability.list_with_start_after","title":"<code>list_with_start_after</code>  <code>property</code>","text":"<p>If backend supports list with start after.</p>"},{"location":"api/capability/#opendal.capability.Capability.presign","title":"<code>presign</code>  <code>property</code>","text":"<p>If operator supports presign.</p>"},{"location":"api/capability/#opendal.capability.Capability.presign_delete","title":"<code>presign_delete</code>  <code>property</code>","text":"<p>If operator supports presign delete.</p>"},{"location":"api/capability/#opendal.capability.Capability.presign_read","title":"<code>presign_read</code>  <code>property</code>","text":"<p>If operator supports presign read.</p>"},{"location":"api/capability/#opendal.capability.Capability.presign_stat","title":"<code>presign_stat</code>  <code>property</code>","text":"<p>If operator supports presign stat.</p>"},{"location":"api/capability/#opendal.capability.Capability.presign_write","title":"<code>presign_write</code>  <code>property</code>","text":"<p>If operator supports presign write.</p>"},{"location":"api/capability/#opendal.capability.Capability.read","title":"<code>read</code>  <code>property</code>","text":"<p>If the operator supports read operations.</p>"},{"location":"api/capability/#opendal.capability.Capability.read_with_if_match","title":"<code>read_with_if_match</code>  <code>property</code>","text":"<p>If conditional read operations using If-Match are supported.</p>"},{"location":"api/capability/#opendal.capability.Capability.read_with_if_modified_since","title":"<code>read_with_if_modified_since</code>  <code>property</code>","text":"<p>If conditional read operations using If-Modified-Since are supported.</p>"},{"location":"api/capability/#opendal.capability.Capability.read_with_if_none_match","title":"<code>read_with_if_none_match</code>  <code>property</code>","text":"<p>If conditional read operations using If-None-Match are supported.</p>"},{"location":"api/capability/#opendal.capability.Capability.read_with_if_unmodified_since","title":"<code>read_with_if_unmodified_since</code>  <code>property</code>","text":"<p>If conditional read operations using If-Unmodified-Since are supported.</p>"},{"location":"api/capability/#opendal.capability.Capability.read_with_override_cache_control","title":"<code>read_with_override_cache_control</code>  <code>property</code>","text":"<p>If Cache-Control header override is supported during read operations.</p>"},{"location":"api/capability/#opendal.capability.Capability.read_with_override_content_disposition","title":"<code>read_with_override_content_disposition</code>  <code>property</code>","text":"<p>If Content-Disposition header can be overridden during read operations.</p>"},{"location":"api/capability/#opendal.capability.Capability.read_with_override_content_type","title":"<code>read_with_override_content_type</code>  <code>property</code>","text":"<p>If Content-Type header override is supported during read operations.</p>"},{"location":"api/capability/#opendal.capability.Capability.read_with_version","title":"<code>read_with_version</code>  <code>property</code>","text":"<p>If versions read operations are supported.</p>"},{"location":"api/capability/#opendal.capability.Capability.rename","title":"<code>rename</code>  <code>property</code>","text":"<p>If operator supports rename.</p>"},{"location":"api/capability/#opendal.capability.Capability.shared","title":"<code>shared</code>  <code>property</code>","text":"<p>If operator supports shared.</p>"},{"location":"api/capability/#opendal.capability.Capability.stat","title":"<code>stat</code>  <code>property</code>","text":"<p>If operator supports stat.</p>"},{"location":"api/capability/#opendal.capability.Capability.stat_with_if_match","title":"<code>stat_with_if_match</code>  <code>property</code>","text":"<p>If operator supports stat with if match.</p>"},{"location":"api/capability/#opendal.capability.Capability.stat_with_if_none_match","title":"<code>stat_with_if_none_match</code>  <code>property</code>","text":"<p>If operator supports stat with if none match.</p>"},{"location":"api/capability/#opendal.capability.Capability.write","title":"<code>write</code>  <code>property</code>","text":"<p>If the operator supports write operations.</p>"},{"location":"api/capability/#opendal.capability.Capability.write_can_append","title":"<code>write_can_append</code>  <code>property</code>","text":"<p>If append operations are supported.</p>"},{"location":"api/capability/#opendal.capability.Capability.write_can_empty","title":"<code>write_can_empty</code>  <code>property</code>","text":"<p>If writing empty content is supported.</p>"},{"location":"api/capability/#opendal.capability.Capability.write_can_multi","title":"<code>write_can_multi</code>  <code>property</code>","text":"<p>If multiple write operations can be performed on the same object.</p>"},{"location":"api/capability/#opendal.capability.Capability.write_multi_max_size","title":"<code>write_multi_max_size</code>  <code>property</code>","text":"<p>Maximum size supported for multipart uploads.</p> <p>For example, AWS S3 supports up to 5GiB per part in multipart uploads.</p>"},{"location":"api/capability/#opendal.capability.Capability.write_multi_min_size","title":"<code>write_multi_min_size</code>  <code>property</code>","text":"<p>Minimum size required for multipart uploads (except for the last part).</p> <p>For example, AWS S3 requires at least 5MiB per part.</p>"},{"location":"api/capability/#opendal.capability.Capability.write_total_max_size","title":"<code>write_total_max_size</code>  <code>property</code>","text":"<p>Maximum total size supported for write operations.</p> <p>For example, Cloudflare D1 has a 1MB total size limit.</p>"},{"location":"api/capability/#opendal.capability.Capability.write_with_cache_control","title":"<code>write_with_cache_control</code>  <code>property</code>","text":"<p>If Cache-Control can be specified during write operations.</p>"},{"location":"api/capability/#opendal.capability.Capability.write_with_content_disposition","title":"<code>write_with_content_disposition</code>  <code>property</code>","text":"<p>If Content-Disposition can be specified during write operations.</p>"},{"location":"api/capability/#opendal.capability.Capability.write_with_content_encoding","title":"<code>write_with_content_encoding</code>  <code>property</code>","text":"<p>If Content-Encoding can be specified during write operations.</p>"},{"location":"api/capability/#opendal.capability.Capability.write_with_content_type","title":"<code>write_with_content_type</code>  <code>property</code>","text":"<p>If Content-Type can be specified during write operations.</p>"},{"location":"api/capability/#opendal.capability.Capability.write_with_if_match","title":"<code>write_with_if_match</code>  <code>property</code>","text":"<p>If conditional write operations using If-Match are supported.</p>"},{"location":"api/capability/#opendal.capability.Capability.write_with_if_none_match","title":"<code>write_with_if_none_match</code>  <code>property</code>","text":"<p>If conditional write operations using If-None-Match are supported.</p>"},{"location":"api/capability/#opendal.capability.Capability.write_with_if_not_exists","title":"<code>write_with_if_not_exists</code>  <code>property</code>","text":"<p>If write operations can be conditional on object non-existence.</p>"},{"location":"api/capability/#opendal.capability.Capability.write_with_user_metadata","title":"<code>write_with_user_metadata</code>  <code>property</code>","text":"<p>If custom user metadata can be attached during write operations.</p>"},{"location":"api/exceptions/","title":"Exceptions","text":"<p>This page documents all exceptions raised by the OpenDAL.</p> <p>               Bases: <code>Exception</code></p> <p>OpenDAL Base Exception.</p> Source code in <code>python/opendal/exceptions.pyi</code> <pre><code>class Error(builtins.Exception):\n    r\"\"\"OpenDAL Base Exception.\"\"\"\n</code></pre> <p>               Bases: <code>Exception</code></p> <p>Already exists.</p> Source code in <code>python/opendal/exceptions.pyi</code> <pre><code>class AlreadyExists(builtins.Exception):\n    r\"\"\"Already exists.\"\"\"\n</code></pre> <p>               Bases: <code>Exception</code></p> <p>Condition not match.</p> Source code in <code>python/opendal/exceptions.pyi</code> <pre><code>class ConditionNotMatch(builtins.Exception):\n    r\"\"\"Condition not match.\"\"\"\n</code></pre> <p>               Bases: <code>Exception</code></p> <p>Config is invalid.</p> Source code in <code>python/opendal/exceptions.pyi</code> <pre><code>class ConfigInvalid(builtins.Exception):\n    r\"\"\"Config is invalid.\"\"\"\n</code></pre> <p>               Bases: <code>Exception</code></p> <p>Is a directory.</p> Source code in <code>python/opendal/exceptions.pyi</code> <pre><code>class IsADirectory(builtins.Exception):\n    r\"\"\"Is a directory.\"\"\"\n</code></pre> <p>               Bases: <code>Exception</code></p> <p>Is same file.</p> Source code in <code>python/opendal/exceptions.pyi</code> <pre><code>class IsSameFile(builtins.Exception):\n    r\"\"\"Is same file.\"\"\"\n</code></pre> <p>               Bases: <code>Exception</code></p> <p>Not a directory.</p> Source code in <code>python/opendal/exceptions.pyi</code> <pre><code>class NotADirectory(builtins.Exception):\n    r\"\"\"Not a directory.\"\"\"\n</code></pre> <p>               Bases: <code>Exception</code></p> <p>Not found.</p> Source code in <code>python/opendal/exceptions.pyi</code> <pre><code>class NotFound(builtins.Exception):\n    r\"\"\"Not found.\"\"\"\n</code></pre> <p>               Bases: <code>Exception</code></p> <p>Permission denied.</p> Source code in <code>python/opendal/exceptions.pyi</code> <pre><code>class PermissionDenied(builtins.Exception):\n    r\"\"\"Permission denied.\"\"\"\n</code></pre> <p>               Bases: <code>Exception</code></p> <p>Unexpected errors.</p> Source code in <code>python/opendal/exceptions.pyi</code> <pre><code>class Unexpected(builtins.Exception):\n    r\"\"\"Unexpected errors.\"\"\"\n</code></pre> <p>               Bases: <code>Exception</code></p> <p>Unsupported operation.</p> Source code in <code>python/opendal/exceptions.pyi</code> <pre><code>class Unsupported(builtins.Exception):\n    r\"\"\"Unsupported operation.\"\"\"\n</code></pre>"},{"location":"api/file/","title":"File","text":"<p>A file-like object for reading and writing data.</p> <p>Created by the <code>open</code> method of the <code>Operator</code> class.</p>"},{"location":"api/file/#opendal.file.File.closed","title":"<code>closed</code>  <code>property</code>","text":"<p>Whether this file is closed.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if this file is closed.</p>"},{"location":"api/file/#opendal.file.File.close","title":"<code>close()</code>","text":"<p>Close this file.</p> <p>This also flushes write buffers, if applicable.</p> Notes <p>A closed file cannot be used for further I/O operations.</p>"},{"location":"api/file/#opendal.file.File.flush","title":"<code>flush()</code>","text":"<p>Flush the underlying writer.</p> Notes <p>Is a no-op if the file is not <code>writable</code>.</p>"},{"location":"api/file/#opendal.file.File.read","title":"<code>read(size=None)</code>","text":"<p>Read at most <code>size</code> bytes from this file.</p> <p>If <code>size</code> is not specified, read until EOF.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>The maximum number of bytes to read.</p> <code>None</code> Notes <p>Fewer bytes may be returned than requested, read in a loop to ensure all bytes are read.</p> <p>Returns:</p> Type Description <code>bytes</code> <p>The bytes read from this file.</p>"},{"location":"api/file/#opendal.file.File.readable","title":"<code>readable()</code>","text":"<p>Whether this file can be read from.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if this file can be read from.</p>"},{"location":"api/file/#opendal.file.File.readinto","title":"<code>readinto(buffer)</code>","text":"<p>Read bytes into a pre-allocated buffer.</p> <p>Parameters:</p> Name Type Description Default <code>buffer</code> <code>bytes | bytearray</code> <p>A writable, pre-allocated buffer to read into.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The number of bytes read.</p>"},{"location":"api/file/#opendal.file.File.readline","title":"<code>readline(size=None)</code>","text":"<p>Read one line from this file.</p> <p>If <code>size</code> is not specified, read until newline.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>The maximum number of bytes to read.</p> <code>None</code> Notes <p>Retains newline characters after each line, unless the file\u2019s last line has no terminating newline.</p> <p>Returns:</p> Type Description <code>bytes</code> <p>The bytes read from this file.</p>"},{"location":"api/file/#opendal.file.File.seek","title":"<code>seek(pos, whence=0)</code>","text":"<p>Change the position of this file to the given byte offset.</p> <p>Parameters:</p> Name Type Description Default <code>pos</code> <code>int</code> <p>The byte offset (position) to set.</p> required <code>whence</code> <code>int</code> <p>The reference point for the offset. 0: start of file (default); 1: current position; 2: end of file.</p> <code>0</code> <p>Returns:</p> Type Description <code>int</code> <p>The new absolute position.</p>"},{"location":"api/file/#opendal.file.File.seekable","title":"<code>seekable()</code>","text":"<p>Whether this file can be repositioned.</p> Notes <p>This is only applicable to readable files.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if this file can be repositioned.</p>"},{"location":"api/file/#opendal.file.File.tell","title":"<code>tell()</code>","text":"<p>Return the current position of this file.</p> <p>Returns:</p> Type Description <code>int</code> <p>The current absolute position.</p>"},{"location":"api/file/#opendal.file.File.writable","title":"<code>writable()</code>","text":"<p>Whether this file can be written to.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if this file can be written to.</p>"},{"location":"api/file/#opendal.file.File.write","title":"<code>write(bs)</code>","text":"<p>Write bytes to this file.</p> <p>Parameters:</p> Name Type Description Default <code>bs</code> <code>bytes</code> <p>The bytes to write to the file.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The number of bytes written.</p>"},{"location":"api/layers/","title":"Layers","text":"<p>This page documents all layers in OpenDAL.</p>"},{"location":"api/layers/#layer","title":"Layer","text":"<p>Layers are used to intercept the operations on the underlying storage.</p>"},{"location":"api/layers/#retrylayer","title":"RetryLayer","text":"<p>               Bases: <code>Layer</code></p> <p>A layer that retries operations that fail with temporary errors.</p> <p>Operations are retried if they fail with an error for which <code>Error.is_temporary</code> returns <code>True</code>. If all retries are exhausted, the error is marked as persistent and then returned.</p> Notes <p>After an operation on a <code>Reader</code> or <code>Writer</code> has failed through all retries, the object is in an undefined state. Reusing it can lead to exceptions.</p>"},{"location":"api/layers/#opendal.layers.RetryLayer.__new__","title":"<code>__new__(max_times=None, factor=None, jitter=False, max_delay=None, min_delay=None)</code>","text":"<p>Create a new RetryLayer.</p> <p>Parameters:</p> Name Type Description Default <code>max_times</code> <code>Optional[int]</code> <p>Maximum number of retry attempts. Defaults to <code>3</code>.</p> <code>None</code> <code>factor</code> <code>Optional[float]</code> <p>Backoff factor applied between retries. Defaults to <code>2.0</code>.</p> <code>None</code> <code>jitter</code> <code>bool</code> <p>Whether to apply jitter to the backoff. Defaults to <code>False</code>.</p> <code>False</code> <code>max_delay</code> <code>Optional[float]</code> <p>Maximum delay (in seconds) between retries. Defaults to <code>60.0</code>.</p> <code>None</code> <code>min_delay</code> <code>Optional[float]</code> <p>Minimum delay (in seconds) between retries. Defaults to <code>1.0</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>RetryLayer</code>"},{"location":"api/layers/#concurrentlimitlayer","title":"ConcurrentLimitLayer","text":"<p>               Bases: <code>Layer</code></p> <p>A layer that limits the number of concurrent operations.</p> Notes <p>All operators wrapped by this layer will share a common semaphore. This allows you to reuse the same layer across multiple operators, ensuring that the total number of concurrent requests across the entire application does not exceed the limit.</p>"},{"location":"api/layers/#opendal.layers.ConcurrentLimitLayer.__new__","title":"<code>__new__(limit)</code>","text":"<p>Create a new ConcurrentLimitLayer.</p> <p>Parameters:</p> Name Type Description Default <code>limit</code> <code>int</code> <p>Maximum number of concurrent operations allowed.</p> required <p>Returns:</p> Type Description <code>ConcurrentLimitLayer</code>"},{"location":"api/layers/#mimeguesslayer","title":"MimeGuessLayer","text":"<p>               Bases: <code>Layer</code></p> <p>A layer that guesses MIME types for objects based on their paths or content.</p> <p>This layer uses the <code>mime_guess</code> crate (see https://crates.io/crates/mime_guess) to infer the <code>Content-Type</code>.</p> Notes <p>This layer will not override a <code>Content-Type</code> that has already been set, either manually or by the backend service. It is only applied if no content type is present.</p> <p>A <code>Content-Type</code> is not guaranteed. If the file extension is uncommon or unknown, the content type will remain unset.</p>"},{"location":"api/layers/#opendal.layers.MimeGuessLayer.__new__","title":"<code>__new__()</code>","text":"<p>Create a new MimeGuessLayer.</p> <p>Returns:</p> Type Description <code>MimeGuessLayer</code>"},{"location":"api/operator/","title":"Operator","text":"<p>The blocking equivalent of <code>AsyncOperator</code>.</p> <p><code>Operator</code> is the entry point for all blocking APIs.</p> See Also <p>AsyncOperator</p>"},{"location":"api/operator/#opendal.Operator.capability","title":"<code>capability()</code>","text":"<p>Get all capabilities of this operator.</p> <p>Returns:</p> Type Description <code>Capability</code> <p>The capability of the operator.</p>"},{"location":"api/operator/#opendal.Operator.check","title":"<code>check()</code>","text":"<p>Check if the operator is able to work correctly.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the operator is not able to work correctly.</p>"},{"location":"api/operator/#opendal.Operator.copy","title":"<code>copy(source, target)</code>","text":"<p>Copy a file from one path to another.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>The path to the source file.</p> required <code>target</code> <code>str</code> <p>The path to the target file.</p> required"},{"location":"api/operator/#opendal.Operator.create_dir","title":"<code>create_dir(path)</code>","text":"<p>Create a directory at the given path.</p> Notes <p>To indicate that a path is a directory, it must end with a <code>/</code>. This operation is always recursive, like <code>mkdir -p</code>.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to the directory.</p> required"},{"location":"api/operator/#opendal.Operator.delete","title":"<code>delete(path)</code>","text":"<p>Delete a file at the given path.</p> Notes <p>This operation will not return an error if the path does not exist.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to the file.</p> required"},{"location":"api/operator/#opendal.Operator.exists","title":"<code>exists(path)</code>","text":"<p>Check if a path exists.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the path exists, False otherwise.</p>"},{"location":"api/operator/#opendal.Operator.layer","title":"<code>layer(layer)</code>","text":"<p>Add a new layer to this operator.</p> <p>Parameters:</p> Name Type Description Default <code>layer</code> <code>Layer</code> <p>The layer to add.</p> required <p>Returns:</p> Type Description <code>Operator</code> <p>A new operator with the layer added.</p>"},{"location":"api/operator/#opendal.Operator.list","title":"<code>list(path, *, limit=None, start_after=None, recursive=None, versions=None, deleted=None)</code>","text":"<p>List entries in the given directory.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to the directory.</p> required <code>limit</code> <code>int</code> <p>The maximum number of entries to return.</p> <code>None</code> <code>start_after</code> <code>str</code> <p>The entry to start after.</p> <code>None</code> <code>recursive</code> <code>bool</code> <p>Whether to list recursively.</p> <code>None</code> <code>versions</code> <code>bool</code> <p>Whether to list versions.</p> <code>None</code> <code>deleted</code> <code>bool</code> <p>Whether to list deleted entries.</p> <code>None</code> <p>Returns:</p> Type Description <code>BlockingLister</code> <p>An iterator over the entries in the directory.</p>"},{"location":"api/operator/#opendal.Operator.open","title":"<code>open(path, mode, **kwargs)</code>","text":"<p>Open a file-like object for the given path.</p> <p>The returning file-like object is a context manager.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to the file.</p> required <code>mode</code> <code>str</code> <p>The mode to open the file in. Only \"rb\" and \"wb\" are supported.</p> required <code>**kwargs</code> <code>Any</code> <p>Additional options for the underlying reader or writer.</p> <code>{}</code> <p>Returns:</p> Type Description <code>File</code> <p>A file-like object.</p>"},{"location":"api/operator/#opendal.Operator.read","title":"<code>read(path, *, version=None, concurrent=None, chunk=None, gap=None, offset=None, prefetch=None, size=None, if_match=None, if_none_match=None, if_modified_since=None, if_unmodified_since=None, content_type=None, cache_control=None, content_disposition=None)</code>","text":"<p>Read the entire contents of a file at the given path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to the file.</p> required <code>version</code> <code>str</code> <p>The version of the file.</p> <code>None</code> <code>concurrent</code> <code>int</code> <p>The number of concurrent readers.</p> <code>None</code> <code>chunk</code> <code>int</code> <p>The size of each chunk.</p> <code>None</code> <code>gap</code> <code>int</code> <p>The gap between each chunk.</p> <code>None</code> <code>offset</code> <code>int</code> <p>The offset of the file.</p> <code>None</code> <code>prefetch</code> <code>int</code> <p>The number of bytes to prefetch.</p> <code>None</code> <code>size</code> <code>int</code> <p>The size of the file.</p> <code>None</code> <code>if_match</code> <code>str</code> <p>The ETag of the file.</p> <code>None</code> <code>if_none_match</code> <code>str</code> <p>The ETag of the file.</p> <code>None</code> <code>if_modified_since</code> <code>str</code> <p>The last modified time of the file.</p> <code>None</code> <code>if_unmodified_since</code> <code>str</code> <p>The last modified time of the file.</p> <code>None</code> <code>content_type</code> <code>str</code> <p>The content type of the file.</p> <code>None</code> <code>cache_control</code> <code>str</code> <p>The cache control of the file.</p> <code>None</code> <code>content_disposition</code> <code>str</code> <p>The content disposition of the file.</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes</code> <p>The contents of the file as bytes.</p>"},{"location":"api/operator/#opendal.Operator.remove_all","title":"<code>remove_all(path)</code>","text":"<p>Recursively remove all files and directories at the given path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to remove.</p> required"},{"location":"api/operator/#opendal.Operator.rename","title":"<code>rename(source, target)</code>","text":"<p>Rename (move) a file from one path to another.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>The path to the source file.</p> required <code>target</code> <code>str</code> <p>The path to the target file.</p> required"},{"location":"api/operator/#opendal.Operator.scan","title":"<code>scan(path, *, limit=None, start_after=None, versions=None, deleted=None)</code>","text":"<p>Recursively list entries in the given directory.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to the directory.</p> required <code>limit</code> <code>int</code> <p>The maximum number of entries to return.</p> <code>None</code> <code>start_after</code> <code>str</code> <p>The entry to start after.</p> <code>None</code> <code>versions</code> <code>bool</code> <p>Whether to list versions.</p> <code>None</code> <code>deleted</code> <code>bool</code> <p>Whether to list deleted entries.</p> <code>None</code> <p>Returns:</p> Type Description <code>BlockingLister</code> <p>An iterator over the entries in the directory.</p>"},{"location":"api/operator/#opendal.Operator.stat","title":"<code>stat(path, *, version=None, if_match=None, if_none_match=None, if_modified_since=None, if_unmodified_since=None, content_type=None, cache_control=None, content_disposition=None)</code>","text":"<p>Get the metadata of a file at the given path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to the file.</p> required <code>version</code> <code>str</code> <p>The version of the file.</p> <code>None</code> <code>if_match</code> <code>str</code> <p>The ETag of the file.</p> <code>None</code> <code>if_none_match</code> <code>str</code> <p>The ETag of the file.</p> <code>None</code> <code>if_modified_since</code> <code>datetime</code> <p>The last modified time of the file.</p> <code>None</code> <code>if_unmodified_since</code> <code>datetime</code> <p>The last modified time of the file.</p> <code>None</code> <code>content_type</code> <code>str</code> <p>The content type of the file.</p> <code>None</code> <code>cache_control</code> <code>str</code> <p>The cache control of the file.</p> <code>None</code> <code>content_disposition</code> <code>str</code> <p>The content disposition of the file.</p> <code>None</code> <p>Returns:</p> Type Description <code>Metadata</code> <p>The metadata of the file.</p>"},{"location":"api/operator/#opendal.Operator.to_async_operator","title":"<code>to_async_operator()</code>","text":"<p>Create a new <code>AsyncOperator</code> from this blocking operator.</p> <p>Returns:</p> Type Description <code>AsyncOperator</code> <p>The async operator.</p>"},{"location":"api/operator/#opendal.Operator.write","title":"<code>write(path, bs, *, append=None, chunk=None, concurrent=None, cache_control=None, content_type=None, content_disposition=None, content_encoding=None, if_match=None, if_none_match=None, if_not_exists=None, user_metadata=None)</code>","text":"<p>Write bytes to a file at the given path.</p> <p>This function will create a file if it does not exist, and will overwrite its contents if it does.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to the file.</p> required <code>bs</code> <code>bytes</code> <p>The contents to write to the file.</p> required <code>append</code> <code>bool</code> <p>Whether to append to the file instead of overwriting it.</p> <code>None</code> <code>chunk</code> <code>int</code> <p>The chunk size to use when writing the file.</p> <code>None</code> <code>concurrent</code> <code>int</code> <p>The number of concurrent requests to make when writing the file.</p> <code>None</code> <code>cache_control</code> <code>str</code> <p>The cache control header to set on the file.</p> <code>None</code> <code>content_type</code> <code>str</code> <p>The content type header to set on the file.</p> <code>None</code> <code>content_disposition</code> <code>str</code> <p>The content disposition header to set on the file.</p> <code>None</code> <code>content_encoding</code> <code>str</code> <p>The content encoding header to set on the file.</p> <code>None</code> <code>if_match</code> <code>str</code> <p>The ETag to match when writing the file.</p> <code>None</code> <code>if_none_match</code> <code>str</code> <p>The ETag to not match when writing the file.</p> <code>None</code> <code>if_not_exists</code> <code>bool</code> <p>Whether to fail if the file already exists.</p> <code>None</code> <code>user_metadata</code> <code>dict</code> <p>The user metadata to set on the file.</p> <code>None</code>"},{"location":"api/types/","title":"Types","text":"<p>This page documents all types in OpenDAL.</p>"},{"location":"api/types/#entry","title":"Entry","text":"<p>Entry.</p> <p>An entry representing a path and its associated metadata.</p> Notes <p>If this entry is a directory, <code>path</code> must end with <code>/</code>. Otherwise, <code>path</code> must not end with <code>/</code>.</p>"},{"location":"api/types/#opendal.types.Entry.metadata","title":"<code>metadata</code>  <code>property</code>","text":"<p>The metadata of this entry.</p>"},{"location":"api/types/#opendal.types.Entry.name","title":"<code>name</code>  <code>property</code>","text":"<p>The name of entry, representing the last segment of the path.</p>"},{"location":"api/types/#opendal.types.Entry.path","title":"<code>path</code>  <code>property</code>","text":"<p>The path of entry relative to the operator's root.</p>"},{"location":"api/types/#entrymode","title":"EntryMode","text":"<p>               Bases: <code>Enum</code></p> <p>EntryMode.</p> <p>The mode of an entry, indicating if it is a file or a directory.</p> Source code in <code>python/opendal/types.pyi</code> <pre><code>@typing.final\nclass EntryMode(enum.Enum):\n    r\"\"\"\n    EntryMode.\n\n    The mode of an entry, indicating if it is a file or a directory.\n    \"\"\"\n\n    File = ...\n    r\"\"\"\n    The entry is a file and has data to read.\n    \"\"\"\n    Dir = ...\n    r\"\"\"\n    The entry is a directory and can be listed.\n    \"\"\"\n    Unknown = ...\n    r\"\"\"\n    The mode of the entry is unknown.\n    \"\"\"\n\n    def is_file(self) -&gt; builtins.bool:\n        r\"\"\"\n        Check if the entry mode is `File`.\n\n        Returns\n        -------\n        bool\n            True if the entry is a file.\n        \"\"\"\n    def is_dir(self) -&gt; builtins.bool:\n        r\"\"\"\n        Check if the entry mode is `Dir`.\n\n        Returns\n        -------\n        bool\n            True if the entry is a directory.\n        \"\"\"\n</code></pre>"},{"location":"api/types/#opendal.types.EntryMode.Dir","title":"<code>Dir = ...</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The entry is a directory and can be listed.</p>"},{"location":"api/types/#opendal.types.EntryMode.File","title":"<code>File = ...</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The entry is a file and has data to read.</p>"},{"location":"api/types/#opendal.types.EntryMode.Unknown","title":"<code>Unknown = ...</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The mode of the entry is unknown.</p>"},{"location":"api/types/#opendal.types.EntryMode.is_dir","title":"<code>is_dir()</code>","text":"<p>Check if the entry mode is <code>Dir</code>.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the entry is a directory.</p> Source code in <code>python/opendal/types.pyi</code> <pre><code>def is_dir(self) -&gt; builtins.bool:\n    r\"\"\"\n    Check if the entry mode is `Dir`.\n\n    Returns\n    -------\n    bool\n        True if the entry is a directory.\n    \"\"\"\n</code></pre>"},{"location":"api/types/#opendal.types.EntryMode.is_file","title":"<code>is_file()</code>","text":"<p>Check if the entry mode is <code>File</code>.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the entry is a file.</p> Source code in <code>python/opendal/types.pyi</code> <pre><code>def is_file(self) -&gt; builtins.bool:\n    r\"\"\"\n    Check if the entry mode is `File`.\n\n    Returns\n    -------\n    bool\n        True if the entry is a file.\n    \"\"\"\n</code></pre>"},{"location":"api/types/#metadata","title":"Metadata","text":"<p>The metadata of an <code>Entry</code>.</p> <p>The metadata is always tied to a specific context and is not a global state. For example, two versions of the same path might have different content lengths.</p> Notes <p>In systems that support versioning, such as AWS S3, the metadata may represent a specific version of a file. Use :attr:<code>version</code> to get the version of a file if it is available.</p>"},{"location":"api/types/#opendal.types.Metadata.content_disposition","title":"<code>content_disposition</code>  <code>property</code>","text":"<p>The content disposition of this entry.</p>"},{"location":"api/types/#opendal.types.Metadata.content_encoding","title":"<code>content_encoding</code>  <code>property</code>","text":"<p>The content encoding of this entry.</p>"},{"location":"api/types/#opendal.types.Metadata.content_length","title":"<code>content_length</code>  <code>property</code>","text":"<p>The content length of this entry.</p>"},{"location":"api/types/#opendal.types.Metadata.content_md5","title":"<code>content_md5</code>  <code>property</code>","text":"<p>The content MD5 of this entry.</p>"},{"location":"api/types/#opendal.types.Metadata.content_type","title":"<code>content_type</code>  <code>property</code>","text":"<p>The content type of this entry.</p>"},{"location":"api/types/#opendal.types.Metadata.etag","title":"<code>etag</code>  <code>property</code>","text":"<p>The ETag of this entry.</p>"},{"location":"api/types/#opendal.types.Metadata.is_dir","title":"<code>is_dir</code>  <code>property</code>","text":"<p>Whether this entry is a directory.</p>"},{"location":"api/types/#opendal.types.Metadata.is_file","title":"<code>is_file</code>  <code>property</code>","text":"<p>Whether this entry is a file.</p>"},{"location":"api/types/#opendal.types.Metadata.last_modified","title":"<code>last_modified</code>  <code>property</code>","text":"<p>The last modified timestamp of this entry.</p>"},{"location":"api/types/#opendal.types.Metadata.mode","title":"<code>mode</code>  <code>property</code>","text":"<p>The mode of this entry.</p>"},{"location":"api/types/#opendal.types.Metadata.user_metadata","title":"<code>user_metadata</code>  <code>property</code>","text":"<p>The user-defined metadata of this entry.</p>"},{"location":"api/types/#opendal.types.Metadata.version","title":"<code>version</code>  <code>property</code>","text":"<p>The version of this entry.</p>"},{"location":"api/types/#presignedrequest","title":"PresignedRequest","text":"<p>A presigned request.</p> <p>This contains the information required to make a request to the underlying service, including the URL, method, and headers.</p>"},{"location":"api/types/#opendal.types.PresignedRequest.headers","title":"<code>headers</code>  <code>property</code>","text":"<p>The HTTP headers of this request.</p> <p>Returns:</p> Type Description <code>dict</code> <p>The HTTP headers of this request.</p>"},{"location":"api/types/#opendal.types.PresignedRequest.method","title":"<code>method</code>  <code>property</code>","text":"<p>The HTTP method of this request.</p>"},{"location":"api/types/#opendal.types.PresignedRequest.url","title":"<code>url</code>  <code>property</code>","text":"<p>The URL of this request.</p>"},{"location":"examples/basic/","title":"Basic","text":"In\u00a0[\u00a0]: Copied! <pre># Install the opendal\n!pip install opendal\n</pre> # Install the opendal !pip install opendal In\u00a0[\u00a0]: Copied! <pre>import opendal\n\n# Init an operator.\nop = opendal.Operator(\"fs\", root=\"/tmp\")\nprint(f\"operator: {op}\")\n\n# Write data into object test.\nop.write(\"test\", b\"Hello, World!\")\n\n# Read data from object\nbs = op.read(\"test\")\nprint(f\"content: {bs.decode()}\")\n\n# Get object metadata.\nmeta = op.stat(\"test\")\nprint(f\"metadata: {meta}\")\n</pre> import opendal  # Init an operator. op = opendal.Operator(\"fs\", root=\"/tmp\") print(f\"operator: {op}\")  # Write data into object test. op.write(\"test\", b\"Hello, World!\")  # Read data from object bs = op.read(\"test\") print(f\"content: {bs.decode()}\")  # Get object metadata. meta = op.stat(\"test\") print(f\"metadata: {meta}\")"},{"location":"examples/pandas/","title":"Pandas","text":"In\u00a0[\u00a0]: Copied! <pre># Install the opendal and pandas\n!pip install opendal, pandas\n</pre> # Install the opendal and pandas !pip install opendal, pandas In\u00a0[\u00a0]: Copied! <pre>import pandas as pd\n\nimport opendal\n\n# Init an operator.\nop = opendal.Operator(\"fs\", root=\"/tmp\")\n\n# Create and write a csv file\nop.write(\"test.csv\", b\"name,age\\nAlice,25\\nBob,30\\nCharlie,35\")\n\n# Open and read the DataFrame from the file.\nwith op.open(\"test.csv\", mode=\"rb\") as file:\n    read_df = pd.read_csv(file)\n    print(f\"read_df: {read_df}\")\n</pre> import pandas as pd  import opendal  # Init an operator. op = opendal.Operator(\"fs\", root=\"/tmp\")  # Create and write a csv file op.write(\"test.csv\", b\"name,age\\nAlice,25\\nBob,30\\nCharlie,35\")  # Open and read the DataFrame from the file. with op.open(\"test.csv\", mode=\"rb\") as file:     read_df = pd.read_csv(file)     print(f\"read_df: {read_df}\")"},{"location":"examples/polars/","title":"Polars","text":"In\u00a0[\u00a0]: Copied! <pre># Install the opendal and polars\n!pip install opendal, polars\n</pre> # Install the opendal and polars !pip install opendal, polars In\u00a0[\u00a0]: Copied! <pre>import polars as pl\n\nimport opendal\n\n# Init an operator.\nop = opendal.Operator(\"fs\", root=\"/tmp\")\n\n# Create a DataFrame.\ndf = pl.DataFrame({\"name\": [\"Alice\", \"Bob\"], \"age\": [20, 30]})\nprint(f\"df: {df}\")\n\n# Open and write the DataFrame to the file.\nwith op.open(\"test.csv\", mode=\"wb\") as file:\n    df.write_csv(file)\n\n# Open and read the DataFrame from the file.\nwith op.open(\"test.csv\", mode=\"rb\") as file:\n    read_df = pl.read_csv(file)\n    print(f\"read_df: {read_df}\")\n</pre> import polars as pl  import opendal  # Init an operator. op = opendal.Operator(\"fs\", root=\"/tmp\")  # Create a DataFrame. df = pl.DataFrame({\"name\": [\"Alice\", \"Bob\"], \"age\": [20, 30]}) print(f\"df: {df}\")  # Open and write the DataFrame to the file. with op.open(\"test.csv\", mode=\"wb\") as file:     df.write_csv(file)  # Open and read the DataFrame from the file. with op.open(\"test.csv\", mode=\"rb\") as file:     read_df = pl.read_csv(file)     print(f\"read_df: {read_df}\")"}]}