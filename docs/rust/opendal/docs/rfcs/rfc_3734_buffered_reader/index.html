<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Buffered Reader"><title>opendal::docs::rfcs::rfc_3734_buffered_reader - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../../static.files/rustdoc-916cea96.css"><meta name="rustdoc-vars" data-root-path="../../../../" data-static-root-path="../../../../static.files/" data-current-crate="opendal" data-themes="" data-resource-suffix="" data-rustdoc-version="1.87.0-nightly (43a2e9d2c 2025-03-17)" data-channel="nightly" data-search-js="search-e7298875.js" data-settings-js="settings-d72f25bb.js"><script src="../../../../static.files/storage-d8ac8691.js"></script><script defer="" src="../sidebar-items.js"></script><script defer="" src="../../../../static.files/main-fb8c74a8.js"></script><noscript><link rel="stylesheet" href="../../../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../../../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../../../static.files/favicon-044be391.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button><a class="logo-container" href="../../../../opendal/index.html"><img src="/img/external/71c0d8847d34b7f8ce3fd204c652c6f9.svg" alt=""></a></nav><nav class="sidebar"><div class="sidebar-crate"><a class="logo-container" href="../../../../opendal/index.html"><img src="/img/external/71c0d8847d34b7f8ce3fd204c652c6f9.svg" alt="logo"></a><h2><a href="../../../../opendal/index.html">opendal</a><span class="version">0.54.1</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module rfc_<wbr>3734_<wbr>buffered_<wbr>reader</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#summary" title="Summary">Summary</a></li><li><a href="#motivation" title="Motivation">Motivation</a></li><li><a href="#guide-level-explanation" title="Guide-level explanation">Guide-level explanation</a></li><li><a href="#reference-level-explanation" title="Reference-level explanation">Reference-level explanation</a></li><li><a href="#drawbacks" title="Drawbacks">Drawbacks</a></li><li><a href="#rationale-and-alternatives" title="Rationale and alternatives">Rationale and alternatives</a></li><li><a href="#prior-art" title="Prior art">Prior art</a></li><li><a href="#unresolved-questions" title="Unresolved questions">Unresolved questions</a></li><li><a href="#future-possibilities" title="Future possibilities">Future possibilities</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="../index.html">In opendal::<wbr>docs::<wbr>rfcs</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../../../index.html">opendal</a>::<wbr><a href="../../index.html">docs</a>::<wbr><a href="../index.html">rfcs</a></div><h1>Module <span>rfc_3734_buffered_reader</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../../../src/opendal/docs/rfcs/mod.rs.html#222">Source</a> </span></div><span class="item-info"><div class="stab portability">Available on <strong><code>docsrs</code></strong> only.</div></span><details class="toggle top-doc" open=""><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Buffered Reader</p>
<ul>
<li>Proposal Name: <code>buffered_reader</code></li>
<li>Start Date: 2023-12-10</li>
<li>RFC PR: <a href="https://github.com/apache/opendal/pull/3734">apache/opendal#3574</a></li>
<li>Tracking Issue: <a href="https://github.com/apache/opendal/issues/3735">apache/opendal#3575</a></li>
</ul>
<h2 id="summary"><a class="doc-anchor" href="#summary">§</a>Summary</h2>
<p>Allowing the underlying reader to fetch data at the buffer’s size to amortize the IO’s overhead.</p>
<h2 id="motivation"><a class="doc-anchor" href="#motivation">§</a>Motivation</h2>
<p>The objective is to mitigate the IO overhead. In certain scenarios, the reader processes the data incrementally, meaning that it utilizes the <code>seek()</code> function to navigate to a specific position within the file. Subsequently, it invokes the <code>read()</code> to reads <code>limit</code> bytes into memory and performs the decoding process.</p>
<p>OpenDAL triggers an IO request upon invoking <code>read()</code> if the <code>seek()</code> has reset the inner state. For storage services like S3, <a href="https://www.vldb.org/pvldb/vol16/p2769-durner.pdf">research</a> suggests that an optimal IO size falls within the range of 8MiB to 16MiB. If the IO size is too small, the Time To First Byte (TTFB) dominates the overall runtime, resulting in inefficiency.</p>
<p>Therefore, this RFC proposes the implementation of a buffered reader to amortize the overhead of IO.</p>
<h2 id="guide-level-explanation"><a class="doc-anchor" href="#guide-level-explanation">§</a>Guide-level explanation</h2>
<p>For users who want to buffered reader, they will call the new API <code>buffer</code>. And the default behavior remains unchanged, so users using <code>op.reader_with()</code> are not affected. The <code>buffer</code> function will take a number as input, and this number will represent the maximum buffer capability the reader is able to use.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>op.reader_with(path).buffer(<span class="number">32 </span>* <span class="number">1024 </span>* <span class="number">1024</span>).<span class="kw">await</span></code></pre></div>
<h2 id="reference-level-explanation"><a class="doc-anchor" href="#reference-level-explanation">§</a>Reference-level explanation</h2>
<p>This feature will be implemented in the <code>CompleteLayer</code>, with the addition of a <code>BufferReader</code> struct in <code>raw/oio/reader/buffer_reader.rs</code>.</p>
<p>The <code>BufferReader</code> employs a <code>tokio::io::ReadBuf</code> as the inner buffer and uses <code>offset: Option&lt;u64&gt;</code> to track the buffered range start of the file, the buffered data should always be <code>file[offset..offset + buf.len()]</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>     ...
     <span class="kw">async fn </span>read(<span class="kw-2">&amp;</span><span class="self">self</span>, path: <span class="kw-2">&amp;</span>str, args: OpRead) -&gt; <span class="prelude-ty">Result</span>&lt;(RpRead, <span class="self">Self</span>::Reader)&gt; {
          BufferReader::new(<span class="self">self</span>.complete_read(path, args).<span class="kw">await</span>)
     }

     ...

    <span class="kw">fn </span>blocking_read(<span class="kw-2">&amp;</span><span class="self">self</span>, path: <span class="kw-2">&amp;</span>str, args: OpRead) -&gt; <span class="prelude-ty">Result</span>&lt;(RpRead, <span class="self">Self</span>::BlockingReader)&gt; {
          BufferReader::new(<span class="self">self</span>.complete_blocking_read(path, args))
    }
     ...</code></pre></div>
<p>A <code>buffer</code> field of type <code>Option&lt;usize&gt;</code> will be introduced to <code>OpRead</code>. If <code>buffer</code> is set to <code>None</code>, it functions with default behavior. However, if buffer is set to <code>Some(n)</code>, it denotes the maximum buffer capability that the <code>BufferReader</code> can utilize. The behavior is similar to <a href="https://doc.rust-lang.org/std/io/struct.BufReader.html">std::io::BufReader</a>, with the difference being that our implementation always provides the <code>seek_relative</code> (without discarding the inner buffer) if it’s available; And it doesn’t buffer trailing reads when the read range is smaller than the buffer capability.</p>
<h2 id="drawbacks"><a class="doc-anchor" href="#drawbacks">§</a>Drawbacks</h2>
<p>None</p>
<h2 id="rationale-and-alternatives"><a class="doc-anchor" href="#rationale-and-alternatives">§</a>Rationale and alternatives</h2>
<p>None</p>
<h2 id="prior-art"><a class="doc-anchor" href="#prior-art">§</a>Prior art</h2>
<p>None</p>
<h2 id="unresolved-questions"><a class="doc-anchor" href="#unresolved-questions">§</a>Unresolved questions</h2>
<p>None</p>
<h2 id="future-possibilities"><a class="doc-anchor" href="#future-possibilities">§</a>Future possibilities</h2>
<ul>
<li>Concurrent fetching.</li>
<li>Tailing buffering.</li>
</ul>
</div></details></section></div></main></body></html>