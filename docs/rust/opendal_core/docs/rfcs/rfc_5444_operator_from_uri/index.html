<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Operator from uri"><title>opendal_core::docs::rfcs::rfc_5444_operator_from_uri - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../../static.files/rustdoc-ca0dd0c4.css"><meta name="rustdoc-vars" data-root-path="../../../../" data-static-root-path="../../../../static.files/" data-current-crate="opendal_core" data-themes="" data-resource-suffix="" data-rustdoc-version="1.92.0-nightly (be0ade2b6 2025-10-11)" data-channel="nightly" data-search-js="search-8d3311b9.js" data-stringdex-js="stringdex-828709d0.js" data-settings-js="settings-c38705f0.js"><script src="../../../../static.files/storage-e2aeef58.js"></script><script defer="" src="../sidebar-items.js"></script><script defer="" src="../../../../static.files/main-ce535bd0.js"></script><noscript><link rel="stylesheet" href="../../../../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../../../../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../../../../static.files/favicon-044be391.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">Module rfc_5444_operator_from_uri</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><a class="logo-container" href="../../../../opendal_core/index.html"><img src="/img/external/71c0d8847d34b7f8ce3fd204c652c6f9.svg" alt="logo"></a><h2><a href="../../../../opendal_core/index.html">opendal_<wbr>core</a><span class="version">0.55.0</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module rfc_<wbr>5444_<wbr>operator_<wbr>from_<wbr>uri</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#summary" title="Summary">Summary</a></li><li><a href="#motivation" title="Motivation">Motivation</a></li><li><a href="#guide-level-explanation" title="Guide-level explanation">Guide-level explanation</a></li><li><a href="#reference-level-explanation" title="Reference-level explanation">Reference-level explanation</a><ul><li><a href="#scheme-enum-removal" title="Scheme Enum Removal">Scheme Enum Removal</a></li></ul></li><li><a href="#drawbacks" title="Drawbacks">Drawbacks</a></li><li><a href="#rationale-and-alternatives" title="Rationale and alternatives">Rationale and alternatives</a></li><li><a href="#prior-art" title="Prior art">Prior art</a></li><li><a href="#unresolved-questions" title="Unresolved questions">Unresolved questions</a></li><li><a href="#future-possibilities" title="Future possibilities">Future possibilities</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="../index.html">In opendal_<wbr>core::<wbr>docs::<wbr>rfcs</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../../../index.html">opendal_core</a>::<wbr><a href="../../index.html">docs</a>::<wbr><a href="../index.html">rfcs</a></div><h1>Module <span>rfc_<wbr>5444_<wbr>operator_<wbr>from_<wbr>uri</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../../../src/opendal_core/docs/rfcs/mod.rs.html#246">Source</a> </span></div><span class="item-info"><div class="stab portability">Available on <strong><code>docsrs</code></strong> only.</div></span><details class="toggle top-doc" open=""><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Operator from uri</p>
<ul>
<li>Proposal Name: <code>operator_from_uri</code></li>
<li>Start Date: 2024-12-23</li>
<li>RFC PR: <a href="https://github.com/apache/opendal/pull/5444">apache/opendal#5444</a></li>
<li>Tracking Issue: <a href="https://github.com/apache/opendal/issues/5445">apache/opendal#5445</a></li>
</ul>
<h2 id="summary"><a class="doc-anchor" href="#summary">§</a>Summary</h2>
<p>This RFC proposes adding URI-based configuration support to OpenDAL, allowing users to create operators directly from URIs. The proposal introduces a new <code>from_uri</code> API in both the <code>Operator</code> and <code>Configurator</code> traits, along with an <code>OperatorRegistry</code> to manage operator factories. As part of this change, we will also transition from the <code>Scheme</code> enum to string-based scheme identifiers, enabling better modularity and support for service crate splitting.</p>
<h2 id="motivation"><a class="doc-anchor" href="#motivation">§</a>Motivation</h2>
<p>Currently, creating an operator in OpenDAL requires explicit configuration through builder patterns. While this approach provides type safety and clear documentation, it can be verbose and inflexible for simple use cases. Many storage systems are naturally identified by URIs (e.g., <code>s3://bucket/path</code>, <code>fs:///path/to/dir</code>).</p>
<p>Adding URI-based configuration would:</p>
<ul>
<li>Simplify operator creation for common use cases</li>
<li>Enable configuration via connection strings (common in many applications)</li>
<li>Make OpenDAL more approachable for new users</li>
<li>Allow dynamic operator creation based on runtime configuration</li>
</ul>
<h2 id="guide-level-explanation"><a class="doc-anchor" href="#guide-level-explanation">§</a>Guide-level explanation</h2>
<p>The new API allows creating operators directly from URIs:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Create an operator using URI
</span><span class="kw">let </span>op = Operator::from_uri(<span class="string">"s3://my-bucket/path"</span>)<span class="question-mark">?</span>;

<span class="comment">// Users can pass options through the URI along with additional key-value pairs
// The extra options will override identical options specified in the URI
</span><span class="kw">let </span>op = Operator::from_uri((
    <span class="string">"s3://my-bucket/path?region=us-east-1"</span>,
    [(<span class="string">"endpoint"</span>, <span class="string">"http://localhost:8080"</span>)],
))<span class="question-mark">?</span>;

<span class="comment">// Create a file system operator
</span><span class="kw">let </span>op = Operator::from_uri(<span class="string">"fs:///tmp/test"</span>)<span class="question-mark">?</span>;</code></pre></div>
<p>OpenDAL will, by default, register services enabled by features in a global <code>OperatorRegistry</code>. Users can also create custom operator registries to support their own schemes or additional options.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Using a custom registry
</span><span class="kw">let </span>registry = OperatorRegistry::new();

<span class="comment">// Register builtin builders under desired schemes
</span>registry.register::&lt;services::S3&gt;(services::S3_SCHEME);
registry.register::&lt;services::S3&gt;(<span class="string">"minio"</span>);  <span class="comment">// MinIO is S3-compatible
</span>registry.register::&lt;services::S3&gt;(<span class="string">"r2"</span>);     <span class="comment">// Cloudflare R2 is S3-compatible

// Users can define their own scheme names for internal use
</span>registry.register::&lt;services::S3&gt;(<span class="string">"company-storage"</span>);
registry.register::&lt;services::Azblob&gt;(<span class="string">"backup-storage"</span>);

<span class="kw">let </span>op = registry.load(<span class="string">"company-storage://bucket/path"</span>)<span class="question-mark">?</span>;</code></pre></div><h2 id="reference-level-explanation"><a class="doc-anchor" href="#reference-level-explanation">§</a>Reference-level explanation</h2>
<p>The implementation consists of three main components:</p>
<ol>
<li>The <code>OperatorFactory</code> and <code>OperatorRegistry</code>:</li>
</ol>
<p><code>OperatorFactory</code> is a function type that takes a parsed <code>OperatorUri</code> and returns an <code>Operator</code>. <code>OperatorRegistry</code> manages factories registered under different schemes.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">type </span>OperatorFactory = <span class="kw">fn</span>(<span class="kw-2">&amp;</span>OperatorUri) -&gt; <span class="prelude-ty">Result</span>&lt;Operator&gt;;

<span class="kw">pub struct </span>OperatorRegistry { ... }

<span class="kw">impl </span>OperatorRegistry {
    <span class="kw">fn </span>register&lt;B: Builder&gt;(<span class="kw-2">&amp;</span><span class="self">self</span>, scheme: <span class="kw-2">&amp;</span>str) {
        ...
    }

    <span class="kw">fn </span>load(<span class="kw-2">&amp;</span><span class="self">self</span>, uri: <span class="kw">impl </span>IntoOperatorUri) -&gt; <span class="prelude-ty">Result</span>&lt;Operator&gt; {
        ...
    }
}</code></pre></div>
<ol start="2">
<li>The <code>Configurator</code> trait extension:</li>
</ol>
<p><code>Configurator</code> will add a new API to create a configuration from a parsed <code>OperatorUri</code>. Services should only inspect the URI components relevant to their configuration (name, root, options) without concerning themselves with the scheme portion.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">impl </span>Configurator <span class="kw">for </span>S3Config {
    <span class="kw">fn </span>from_uri(uri: <span class="kw-2">&amp;</span>OperatorUri) -&gt; <span class="prelude-ty">Result</span>&lt;<span class="self">Self</span>&gt; {
        ...
    }
}</code></pre></div>
<p>This design allows the same S3 implementation to work whether accessed via <code>s3://</code>, <code>minio://</code>, or any other user-defined scheme.</p>
<ol start="3">
<li>The <code>Operator</code> <code>from_uri</code> method:</li>
</ol>
<p>The <code>Operator</code> trait will add a new <code>from_uri</code> method to create an operator from a URI and options. This method will use the global <code>OperatorRegistry</code> to find the appropriate factory for the scheme.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">impl </span>Operator {
    <span class="kw">pub fn </span>from_uri(uri: <span class="kw">impl </span>IntoOperatorUri) -&gt; <span class="prelude-ty">Result</span>&lt;<span class="self">Self</span>&gt; {
        ...
    }
}</code></pre></div><h3 id="scheme-enum-removal"><a class="doc-anchor" href="#scheme-enum-removal">§</a>Scheme Enum Removal</h3>
<p>As part of this RFC, we will transition from the <code>Scheme</code> enum to string-based identifiers (<code>&amp;'static str</code>). This change is necessary because:</p>
<ol>
<li><strong>Modularity</strong>: Services in separate crates cannot add variants to a core enum</li>
<li><strong>Extensibility</strong>: Users and third-party crates can define custom schemes without modifying OpenDAL</li>
<li><strong>Simplicity</strong>: Services don’t need to know their scheme identifier</li>
</ol>
<h2 id="drawbacks"><a class="doc-anchor" href="#drawbacks">§</a>Drawbacks</h2>
<ul>
<li>Increases API surface area</li>
<li>Less type safety compared to builder patterns</li>
<li>Potential for confusing error messages with invalid URIs</li>
<li>Need to maintain backwards compatibility</li>
</ul>
<h2 id="rationale-and-alternatives"><a class="doc-anchor" href="#rationale-and-alternatives">§</a>Rationale and alternatives</h2>
<p>Alternatives considered:</p>
<ol>
<li>Connection string format instead of URIs</li>
<li>Builder pattern with URI parsing</li>
<li>Macro-based configuration</li>
</ol>
<p>URI-based configuration was chosen because:</p>
<ul>
<li>URIs are widely understood</li>
<li>Natural fit for storage locations</li>
<li>Extensible through custom schemes</li>
<li>Common in similar tools</li>
</ul>
<h2 id="prior-art"><a class="doc-anchor" href="#prior-art">§</a>Prior art</h2>
<p>Similar patterns exist in:</p>
<ul>
<li>Database connection strings (PostgreSQL, MongoDB)</li>
<li><a href="https://docs.rs/object_store/latest/object_store/fn.parse_url.html"><code>object_store::parse_url</code></a></li>
</ul>
<h2 id="unresolved-questions"><a class="doc-anchor" href="#unresolved-questions">§</a>Unresolved questions</h2>
<p>None</p>
<h2 id="future-possibilities"><a class="doc-anchor" href="#future-possibilities">§</a>Future possibilities</h2>
<ul>
<li>Support for connection string format</li>
<li>Configuration presets like <code>r2</code> and <code>s3</code> with directory bucket enabled</li>
<li>Service crate splitting: Each service can live in its own crate and register itself with the core</li>
<li>Plugin system: Allow dynamic loading of service implementations at runtime</li>
<li>Service discovery: Automatically register available services based on feature flags or runtime detection</li>
<li>Scheme validation and conventions: Provide utilities to validate scheme naming conventions</li>
</ul>
</div></details></section></div></main></body></html>